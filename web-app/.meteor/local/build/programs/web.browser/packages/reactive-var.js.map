)]}'
{"version":3,"sources":["reactive-var/reactive-var.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,mD;AACA,E;AACA,8D;AACA,gE;AACA,6D;AACA,gB;AACA,E;AACA,uE;AACA,yE;AACA,sE;AACA,0E;AACA,E;AACA,uE;AACA,wE;AACA,8D;AACA,qE;AACA,kE;AACA,uE;AACA,uE;AACA,yE;AACA,qE;AACA,sC;AACA,E;AACA,qE;AACA,8D;AACA,G;;AAEA,G;AACA,U;AACA,4B;AACA,uF;AACA,gB;AACA,+G;AACA,yU;AACA,G;AACA,mD;AACA,sC;AACA,2B;AACA,qD;;AAEA,+B;AACA,+B;AACA,oC;AACA,E;;AAEA,sD;AACA,iC;AACA,0D;AACA,iD;AACA,c;AACA,iB;AACA,M;AACA,0E;AACA,qC;AACA,E;;AAEA,G;AACA,6F;AACA,gB;AACA,G;AACA,yC;AACA,qB;AACA,sB;;AAEA,uB;AACA,E;;AAEA,G;AACA,qJ;AACA,gB;AACA,wB;AACA,G;AACA,iD;AACA,+B;;AAEA,oE;AACA,iC;AACA,W;;AAEA,2B;AACA,qB;AACA,E;;AAEA,8C;AACA,2C;AACA,E;;AAEA,kD;AACA,wB;AACA,oD;AACA,gB;AACA,0C;AACA,Y;AACA,e;AACA,E","file":"/packages/reactive-var.js","sourcesContent":["/*\n * ## [new] ReactiveVar(initialValue, [equalsFunc])\n *\n * A ReactiveVar holds a single value that can be get and set,\n * such that calling `set` will invalidate any Computations that\n * called `get`, according to the usual contract for reactive\n * data sources.\n *\n * A ReactiveVar is much like a Session variable -- compare `foo.get()`\n * to `Session.get(\"foo\")` -- but it doesn't have a global name and isn't\n * automatically migrated across hot code pushes.  Also, while Session\n * variables can only hold JSON or EJSON, ReactiveVars can hold any value.\n *\n * An important property of ReactiveVars, which is sometimes the reason\n * to use one, is that setting the value to the same value as before has\n * no effect, meaning ReactiveVars can be used to absorb extra\n * invalidations that wouldn't serve a purpose.  However, by default,\n * ReactiveVars are extremely conservative about what changes they\n * absorb.  Calling `set` with an object argument will *always* trigger\n * invalidations, because even if the new value is `===` the old value,\n * the object may have been mutated.  You can change the default behavior\n * by passing a function of two arguments, `oldValue` and `newValue`,\n * to the constructor as `equalsFunc`.\n *\n * This class is extremely basic right now, but the idea is to evolve\n * it into the ReactiveVar of Geoff's Lickable Forms proposal.\n */\n\n/**\n * @class \n * @instanceName reactiveVar\n * @summary Constructor for a ReactiveVar, which represents a single reactive variable.\n * @locus Client\n * @param {Any} initialValue The initial value to set.  `equalsFunc` is ignored when setting the initial value.\n * @param {Function} [equalsFunc] Optional.  A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set.  If it returns true, no set is performed.  If omitted, the default `equalsFunc` returns true if its arguments are `===` and are of type number, boolean, string, undefined, or null.\n */\nReactiveVar = function (initialValue, equalsFunc) {\n  if (! (this instanceof ReactiveVar))\n    // called without `new`\n    return new ReactiveVar(initialValue, equalsFunc);\n\n  this.curValue = initialValue;\n  this.equalsFunc = equalsFunc;\n  this.dep = new Tracker.Dependency;\n};\n\nReactiveVar._isEqual = function (oldValue, newValue) {\n  var a = oldValue, b = newValue;\n  // Two values are \"equal\" here if they are `===` and are\n  // number, boolean, string, undefined, or null.\n  if (a !== b)\n    return false;\n  else\n    return ((!a) || (typeof a === 'number') || (typeof a === 'boolean') ||\n            (typeof a === 'string'));\n};\n\n/**\n * @summary Returns the current value of the ReactiveVar, establishing a reactive dependency.\n * @locus Client\n */\nReactiveVar.prototype.get = function () {\n  if (Tracker.active)\n    this.dep.depend();\n\n  return this.curValue;\n};\n\n/**\n * @summary Sets the current value of the ReactiveVar, invalidating the Computations that called `get` if `newValue` is different from the old value.\n * @locus Client\n * @param {Any} newValue\n */\nReactiveVar.prototype.set = function (newValue) {\n  var oldValue = this.curValue;\n\n  if ((this.equalsFunc || ReactiveVar._isEqual)(oldValue, newValue))\n    // value is same as last time\n    return;\n\n  this.curValue = newValue;\n  this.dep.changed();\n};\n\nReactiveVar.prototype.toString = function () {\n  return 'ReactiveVar{' + this.get() + '}';\n};\n\nReactiveVar.prototype._numListeners = function() {\n  // Tests want to know.\n  // Accesses a private field of Tracker.Dependency.\n  var count = 0;\n  for (var id in this.dep._dependentsById)\n    count++;\n  return count;\n};\n"]}