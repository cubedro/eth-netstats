)]}'
{"version":3,"sources":["autoupdate/autoupdate_client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kE;AACA,wD;AACA,E;AACA,sE;AACA,mE;AACA,uE;AACA,uD;AACA,E;AACA,+D;AACA,gE;AACA,2B;AACA,E;AACA,sE;AACA,qE;AACA,mC;AACA,E;AACA,kE;AACA,yE;AACA,c;AACA,E;AACA,oE;AACA,kE;AACA,sC;;AAEA,iE;AACA,W;AACA,iF;AACA,kC;AACA,sE;;AAEA,gD;AACA,0E;;AAEA,gB;;AAEA,6C;AACA,oC;AACA,8B;AACA,sD;AACA,oC;AACA,0C;AACA,+D;AACA,E;;AAEA,oC;;AAEA,uB;AACA,0E;AACA,yE;AACA,qC;AACA,I;AACA,uE;AACA,uE;AACA,mE;AACA,+D;AACA,gD;AACA,wC;AACA,G;AACA,iB;;AAEA,6C;AACA,wD;AACA,+B;AACA,8D;AACA,iB;AACA,8C;AACA,qE;AACA,qE;AACA,wE;AACA,mE;AACA,+D;AACA,wE;AACA,+B;AACA,wC;AACA,S;AACA,M;AACA,0B;AACA,2B;AACA,sD;AACA,0B;AACA,kD;AACA,6D;AACA,uD;AACA,2E;AACA,0F;AACA,iE;AACA,8B;AACA,2E;AACA,wD;AACA,oC;AACA,e;AACA,e;;AAEA,gE;AACA,qD;AACA,yC;AACA,+C;AACA,kC;AACA,gB;AACA,8C;AACA,yD;AACA,mC;AACA,sC;AACA,6C;AACA,mB;AACA,uB;AACA,e;AACA,c;;AAEA,qE;AACA,mD;AACA,wD;AACA,iB;AACA,e;;AAEA,2D;AACA,iF;;AAEA,sD;AACA,uD;AACA,iB;AACA,c;;AAEA,sC;AACA,6C;AACA,6D;AACA,0D;AACA,yD;AACA,gE;AACA,qF;AACA,8C;AACA,iB;AACA,oB;AACA,+B;AACA,a;;AAEA,W;AACA,gF;AACA,oC;AACA,4C;AACA,W;AACA,U;;AAEA,oD;AACA,yC;AACA,0C;AACA,W;AACA,O;AACA,K;AACA,K;AACA,E;AACA,gC","file":"/packages/autoupdate.js","sourcesContent":["// Subscribe to the `meteor_autoupdate_clientVersions` collection,\n// which contains the set of acceptable client versions.\n//\n// A \"hard code push\" occurs when the running client version is not in\n// the set of acceptable client versions (or the server updates the\n// collection, there is a published client version marked `current` and\n// the running client version is no longer in the set).\n//\n// When the `reload` package is loaded, a hard code push causes\n// the browser to reload, so that it will load the latest client\n// version from the server.\n//\n// A \"soft code push\" represents the situation when the running client\n// version is in the set of acceptable versions, but there is a newer\n// version available on the server.\n//\n// `Autoupdate.newClientAvailable` is a reactive data source which\n// becomes `true` if there is a new version of the client is available on\n// the server.\n//\n// This package doesn't implement a soft code reload process itself,\n// but `newClientAvailable` could be used for example to display a\n// \"click to reload\" link to the user.\n\n// The client version of the client code currently running in the\n// browser.\nvar autoupdateVersion = __meteor_runtime_config__.autoupdateVersion || \"unknown\";\nvar autoupdateVersionRefreshable =\n  __meteor_runtime_config__.autoupdateVersionRefreshable || \"unknown\";\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\");\n\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !! ClientVersions.findOne({\n               _id: \"version\",\n               version: {$ne: autoupdateVersion} }) ||\n         !! ClientVersions.findOne({\n               _id: \"version-refreshable\",\n               version: {$ne: autoupdateVersionRefreshable} });\n};\n\nvar knownToSupportCssOnLoad = false;\n\nvar retry = new Retry({\n  // Unlike the stream reconnect use of Retry, which we want to be instant\n  // in normal operation, this is a wacky failure. We don't want to retry\n  // right away, we can start slowly.\n  //\n  // A better way than timeconstants here might be to use the knowledge\n  // of when we reconnect to help trigger these retries. Typically, the\n  // server fixing code will result in a restart and reconnect, but\n  // potentially the subscription could have a transient error.\n  minCount: 0, // don't do any immediate retries\n  baseTimeout: 30*1000 // start with 30s\n});\nvar failures = 0;\n\nAutoupdate._retrySubscription = function () {\n  Meteor.subscribe(\"meteor_autoupdate_clientVersions\", {\n    onError: function (error) {\n      Meteor._debug(\"autoupdate subscription failed:\", error);\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    },\n    onReady: function () {\n      if (Package.reload) {\n        var checkNewVersionDocument = function (doc) {\n          var self = this;\n          if (doc._id === 'version-refreshable' &&\n              doc.version !== autoupdateVersionRefreshable) {\n            autoupdateVersionRefreshable = doc.version;\n            // Switch out old css links for the new css links. Inspired by:\n            // https://github.com/guard/guard-livereload/blob/master/js/livereload.js#L710\n            var newCss = (doc.assets && doc.assets.allCss) || [];\n            var oldLinks = [];\n            _.each(document.getElementsByTagName('link'), function (link) {\n              if (link.className === '__meteor-css__') {\n                oldLinks.push(link);\n              }\n            });\n\n            var waitUntilCssLoads = function  (link, callback) {\n              var executeCallback = _.once(callback);\n              link.onload = function () {\n                knownToSupportCssOnLoad = true;\n                executeCallback();\n              };\n              if (! knownToSupportCssOnLoad) {\n                var id = Meteor.setInterval(function () {\n                  if (link.sheet) {\n                    executeCallback();\n                    Meteor.clearInterval(id);\n                  }\n                }, 50);\n              }\n            };\n\n            var removeOldLinks = _.after(newCss.length, function () {\n              _.each(oldLinks, function (oldLink) {\n                oldLink.parentNode.removeChild(oldLink);\n              });\n            });\n\n            var attachStylesheetLink = function (newLink) {\n              document.getElementsByTagName(\"head\").item(0).appendChild(newLink);\n\n              waitUntilCssLoads(newLink, function () {\n                Meteor.setTimeout(removeOldLinks, 200);\n              });\n            };\n\n            if (newCss.length !== 0) {\n              _.each(newCss, function (css) {\n                var newLink = document.createElement(\"link\");\n                newLink.setAttribute(\"rel\", \"stylesheet\");\n                newLink.setAttribute(\"type\", \"text/css\");\n                newLink.setAttribute(\"class\", \"__meteor-css__\");\n                newLink.setAttribute(\"href\", Meteor._relativeToSiteRootUrl(css.url));\n                attachStylesheetLink(newLink);\n              });\n            } else {\n              removeOldLinks();\n            }\n\n          }\n          else if (doc._id === 'version' && doc.version !== autoupdateVersion) {\n            handle && handle.stop();\n            Package.reload.Reload._reload();\n          }\n        };\n\n        var handle = ClientVersions.find().observe({\n          added: checkNewVersionDocument,\n          changed: checkNewVersionDocument\n        });\n      }\n    }\n  });\n};\nAutoupdate._retrySubscription();\n"]}