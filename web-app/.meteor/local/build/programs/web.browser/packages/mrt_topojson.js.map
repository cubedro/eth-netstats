)]}'
{"version":3,"file":"/packages/mrt:topojson.js","sources":["mrt:topojson/topojson.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,a;AACA,c;AACA,qB;AACA,2F;AACA,uB;AACA,6F;AACA,yB;AACA,iC;AACA,yB;AACA,4B;AACA,I;;AAEA,uC;AACA,0B;AACA,6B;AACA,2B;AACA,uB;AACA,wB;;AAEA,yE;AACA,iC;AACA,iD;AACA,uD;AACA,kE;AACA,O;AACA,O;;AAEA,8B;AACA,sB;AACA,uB;AACA,qB;AACA,e;;AAEA,qC;AACA,oC;AACA,kB;AACA,oB;AACA,uC;AACA,0C;AACA,6C;AACA,mF;AACA,gB;AACA,8D;AACA,S;AACA,4C;AACA,wC;AACA,qB;AACA,wB;AACA,uC;AACA,sC;AACA,6C;AACA,mF;AACA,gB;AACA,8D;AACA,S;AACA,c;AACA,gB;AACA,0E;AACA,O;AACA,O;;AAEA,sB;AACA,+D;AACA,yG;AACA,oC;AACA,yC;AACA,K;;AAEA,oD;AACA,oC;AACA,iC;AACA,wC;AACA,uB;AACA,qB;AACA,qE;AACA,0B;AACA,O;AACA,K;;AAEA,0C;AACA,0C;AACA,0F;;AAEA,qB;AACA,G;;AAEA,0C;AACA,kB;;AAEA,+B;AACA,0B;AACA,e;;AAEA,uB;AACA,+B;AACA,sE;AACA,O;;AAEA,2B;AACA,0B;AACA,O;;AAEA,8B;AACA,2B;AACA,O;;AAEA,4B;AACA,4E;AACA,gF;AACA,O;;AAEA,0B;AACA,yB;AACA,iC;AACA,yB;AACA,+D;AACA,Q;;AAEA,kB;;AAEA,6C;AACA,sD;AACA,2G;AACA,Y;AACA,yE;AACA,K;;AAEA,uE;AACA,G;;AAEA,yC;AACA,2B;AACA,sB;AACA,wB;;AAEA,iC;AACA,iD;AACA,mE;AACA,O;;AAEA,gC;AACA,sC;AACA,oC;AACA,iG;AACA,W;AACA,S;AACA,6B;AACA,K;;AAEA,6B;AACA,8H;AACA,K;;AAEA,wC;AACA,uB;AACA,2B;AACA,kC;AACA,sB;AACA,mC;AACA,2C;AACA,kC;AACA,0C;AACA,wC;AACA,6E;AACA,iC;AACA,gC;AACA,0C;AACA,iB;AACA,iB;AACA,e;AACA,a;AACA,S;AACA,O;AACA,O;;AAEA,wC;AACA,uB;AACA,O;;AAEA,Y;AACA,2B;AACA,+C;AACA,sB;;AAEA,8C;AACA,4C;AACA,0C;AACA,wC;AACA,mE;AACA,+B;AACA,e;AACA,e;AACA,a;AACA,W;;AAEA,kD;AACA,0C;;AAEA,6C;AACA,0D;AACA,wD;AACA,yD;AACA,oC;AACA,6C;AACA,0C;AACA,4C;AACA,0D;AACA,oB;AACA,a;AACA,W;AACA,S;;AAEA,oB;AACA,Q;AACA,M;AACA,G;;AAEA,6C;AACA,8C;AACA,gC;AACA,8E;AACA,6B;AACA,G;;AAEA,iC;AACA,a;AACA,sB;AACA,e;AACA,qC;AACA,mC;AACA,M;AACA,kC;AACA,a;AACA,G;;AAEA,gC;AACA,yD;AACA,6B;;AAEA,6B;AACA,sC;AACA,8E;AACA,sC;AACA,uB;AACA,O;AACA,oC;AACA,K;;AAEA,uB;AACA,oB;AACA,qB;AACA,e;AACA,K;;AAEA,yB;AACA,sB;AACA,wE;AACA,4D;AACA,oB;AACA,K;;AAEA,yB;AACA,8B;AACA,+D;AACA,oB;AACA,K;;AAEA,4B;AACA,4B;AACA,K;;AAEA,0B;AACA,qB;AACA,2F;AACA,0E;AACA,iB;AACA,K;;AAEA,wB;AACA,0D;AACA,mE;AACA,uD;AACA,gE;AACA,uD;AACA,+D;AACA,M;;AAEA,uB;AACA,G;;AAEA,8B;AACA,0G;AACA,G;;AAEA,yB;AACA,8B;AACA,qB;AACA,8B;AACA,mC;AACA,oB;AACA,K;AACA,c;AACA,G;;AAEA,+B;AACA,kE;AACA,2D;;AAEA,4B;AACA,gC;AACA,0B;AACA,gC;AACA,yB;AACA,mC;AACA,S;AACA,K;;AAEA,+B;AACA,oD;AACA,K;;AAEA,6B;AACA,iG;AACA,uE;AACA,K;;AAEA,wB;AACA,uB;AACA,+B;AACA,uB;AACA,2F;AACA,M;;AAEA,8B;;AAEA,iC;AACA,kF;AACA,yC;AACA,kD;AACA,gF;AACA,gF;AACA,S;AACA,O;AACA,K;;AAEA,qB;AACA,G;;AAEA,gD;AACA,yD;AACA,yD;AACA,6B;AACA,oB;AACA,iB;;AAEA,4D;;AAEA,yC;AACA,yB;;AAEA,4B;;AAEA,uD;AACA,2C;AACA,gD;AACA,iC;AACA,4B;AACA,O;;AAEA,uC;AACA,uC;;AAEA,yD;AACA,gC;AACA,6C;AACA,yC;AACA,O;AACA,O;;AAEA,mC;AACA,uC;AACA,+B;;AAEA,iF;AACA,+E;AACA,2E;AACA,2B;AACA,6D;AACA,oC;;AAEA,qB;AACA,6B;AACA,kC;AACA,yB;AACA,O;;AAEA,iB;AACA,iC;AACA,8B;AACA,qB;AACA,O;AACA,K;;AAEA,yC;AACA,4B;AACA,O;;AAEA,+B;AACA,4B;AACA,8C;AACA,0B;AACA,K;;AAEA,oB;AACA,I;;AAEA,oC;AACA,e;AACA,wB;AACA,U;AACA,wB;AACA,iB;;AAEA,qB;AACA,Y;AACA,kB;AACA,wC;AACA,K;;AAEA,qB;AACA,G;;AAEA,4C;AACA,0D;AACA,mF;AACA,G;;AAEA,8B;AACA,6B;AACA,G;;AAEA,0B;AACA,kB;AACA,mB;AACA,iB;;AAEA,kC;AACA,kD;AACA,kB;AACA,M;;AAEA,2B;AACA,4B;AACA,qC;AACA,kF;AACA,qB;AACA,M;;AAEA,qC;AACA,gC;AACA,0D;AACA,8H;AACA,e;AACA,M;;AAEA,4B;AACA,qB;AACA,mC;AACA,8B;AACA,oD;AACA,qC;AACA,yC;AACA,O;AACA,K;;AAEA,8B;AACA,oB;AACA,6B;AACA,sB;AACA,kB;AACA,6B;AACA,+E;AACA,+E;AACA,2B;AACA,mC;AACA,yC;AACA,O;AACA,K;;AAEA,gB;AACA,G;;AAEA,yC;AACA,gC;AACA,W;AACA,W;AACA,gC;AACA,gC;AACA,oC;AACA,oC;AACA,+B;AACA,0B;AACA,4C;AACA,4C;AACA,M;AACA,G;;AAEA,yC;AACA,gC;AACA,W;AACA,W;AACA,gC;AACA,gC;AACA,oC;AACA,oC;AACA,+B;AACA,0B;AACA,wC;AACA,wC;AACA,yB;AACA,yB;AACA,c;AACA,c;AACA,M;AACA,G;;AAEA,oB;;AAEA,mE;AACA,mF;AACA,gC;AACA,I","sourcesContent":["!function() {\n  topojson = {\n    version: \"1.6.8\",\n    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },\n    meshArcs: meshArcs,\n    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },\n    mergeArcs: mergeArcs,\n    feature: featureOrCollection,\n    neighbors: neighbors,\n    presimplify: presimplify\n  };\n\n  function stitchArcs(topology, arcs) {\n    var stitchedArcs = {},\n        fragmentByStart = {},\n        fragmentByEnd = {},\n        fragments = [],\n        emptyIndex = -1;\n\n    // Stitch empty arcs first, since they may be subsumed by other arcs.\n    arcs.forEach(function(i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i], t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n\n    arcs.forEach(function(i) {\n      var e = ends(i),\n          start = e[0],\n          end = e[1],\n          f, g;\n\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n      else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n        fragments.push(f);\n      }\n    }\n\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n    return fragments;\n  }\n\n  function meshArcs(topology, o, filter) {\n    var arcs = [];\n\n    if (arguments.length > 1) {\n      var geomsByArc = [],\n          geom;\n\n      function arc(i) {\n        var j = i < 0 ? ~i : i;\n        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n      }\n\n      function line(arcs) {\n        arcs.forEach(arc);\n      }\n\n      function polygon(arcs) {\n        arcs.forEach(line);\n      }\n\n      function geometry(o) {\n        if (o.type === \"GeometryCollection\") o.geometries.forEach(geometry);\n        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);\n      }\n\n      var geometryType = {\n        LineString: line,\n        MultiLineString: polygon,\n        Polygon: polygon,\n        MultiPolygon: function(arcs) { arcs.forEach(polygon); }\n      };\n\n      geometry(o);\n\n      geomsByArc.forEach(arguments.length < 3\n          ? function(geoms) { arcs.push(geoms[0].i); }\n          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n    } else {\n      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);\n    }\n\n    return {type: \"MultiLineString\", arcs: stitchArcs(topology, arcs)};\n  }\n\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n        polygons = [],\n        components = [];\n\n    objects.forEach(function(o) {\n      if (o.type === \"Polygon\") register(o.arcs);\n      else if (o.type === \"MultiPolygon\") o.arcs.forEach(register);\n    });\n\n    function register(polygon) {\n      polygon.forEach(function(ring) {\n        ring.forEach(function(arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n\n    function exterior(ring) {\n      return cartesianRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?\n    }\n\n    polygons.forEach(function(polygon) {\n      if (!polygon._) {\n        var component = [],\n            neighbors = [polygon];\n        polygon._ = 1;\n        components.push(component);\n        while (polygon = neighbors.pop()) {\n          component.push(polygon);\n          polygon.forEach(function(ring) {\n            ring.forEach(function(arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n\n    polygons.forEach(function(polygon) {\n      delete polygon._;\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      arcs: components.map(function(polygons) {\n        var arcs = [];\n\n        // Extract the exterior (unique) arcs.\n        polygons.forEach(function(polygon) {\n          polygon.forEach(function(ring) {\n            ring.forEach(function(arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n\n        // Stitch the arcs into one or more rings.\n        arcs = stitchArcs(topology, arcs);\n\n        // If more than one ring is returned,\n        // at most one of these rings can be the exterior;\n        // this exterior ring has the same winding order\n        // as any exterior ring in the original polygons.\n        if ((n = arcs.length) > 1) {\n          var sgn = exterior(polygons[0][0]);\n          for (var i = 0, t; i < n; ++i) {\n            if (sgn === exterior(arcs[i])) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;\n              break;\n            }\n          }\n        }\n\n        return arcs;\n      })\n    };\n  }\n\n  function featureOrCollection(topology, o) {\n    return o.type === \"GeometryCollection\" ? {\n      type: \"FeatureCollection\",\n      features: o.geometries.map(function(o) { return feature(topology, o); })\n    } : feature(topology, o);\n  }\n\n  function feature(topology, o) {\n    var f = {\n      type: \"Feature\",\n      id: o.id,\n      properties: o.properties || {},\n      geometry: object(topology, o)\n    };\n    if (o.id == null) delete f.id;\n    return f;\n  }\n\n  function object(topology, o) {\n    var absolute = transformAbsolute(topology.transform),\n        arcs = topology.arcs;\n\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {\n        points.push(p = a[k].slice());\n        absolute(p, k);\n      }\n      if (i < 0) reverse(points, n);\n    }\n\n    function point(p) {\n      p = p.slice();\n      absolute(p, 0);\n      return p;\n    }\n\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n      if (points.length < 2) points.push(points[0].slice());\n      return points;\n    }\n\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) points.push(points[0].slice());\n      return points;\n    }\n\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n\n    function geometry(o) {\n      var t = o.type;\n      return t === \"GeometryCollection\" ? {type: t, geometries: o.geometries.map(geometry)}\n          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}\n          : null;\n    }\n\n    var geometryType = {\n      Point: function(o) { return point(o.coordinates); },\n      MultiPoint: function(o) { return o.coordinates.map(point); },\n      LineString: function(o) { return line(o.arcs); },\n      MultiLineString: function(o) { return o.arcs.map(line); },\n      Polygon: function(o) { return polygon(o.arcs); },\n      MultiPolygon: function(o) { return o.arcs.map(polygon); }\n    };\n\n    return geometry(o);\n  }\n\n  function reverse(array, n) {\n    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n  }\n\n  function bisect(a, x) {\n    var lo = 0, hi = a.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (a[mid] < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function neighbors(objects) {\n    var indexesByArc = {}, // arc index -> array of object indexes\n        neighbors = objects.map(function() { return []; });\n\n    function line(arcs, i) {\n      arcs.forEach(function(a) {\n        if (a < 0) a = ~a;\n        var o = indexesByArc[a];\n        if (o) o.push(i);\n        else indexesByArc[a] = [i];\n      });\n    }\n\n    function polygon(arcs, i) {\n      arcs.forEach(function(arc) { line(arc, i); });\n    }\n\n    function geometry(o, i) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n    }\n\n    var geometryType = {\n      LineString: line,\n      MultiLineString: polygon,\n      Polygon: polygon,\n      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n    };\n\n    objects.forEach(geometry);\n\n    for (var i in indexesByArc) {\n      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n        for (var k = j + 1; k < m; ++k) {\n          var ij = indexes[j], ik = indexes[k], n;\n          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  function presimplify(topology, triangleArea) {\n    var absolute = transformAbsolute(topology.transform),\n        relative = transformRelative(topology.transform),\n        heap = minAreaHeap(),\n        maxArea = 0,\n        triangle;\n\n    if (!triangleArea) triangleArea = cartesianTriangleArea;\n\n    topology.arcs.forEach(function(arc) {\n      var triangles = [];\n\n      arc.forEach(absolute);\n\n      for (var i = 1, n = arc.length - 1; i < n; ++i) {\n        triangle = arc.slice(i - 1, i + 2);\n        triangle[1][2] = triangleArea(triangle);\n        triangles.push(triangle);\n        heap.push(triangle);\n      }\n\n      // Always keep the arc endpoints!\n      arc[0][2] = arc[n][2] = Infinity;\n\n      for (var i = 0, n = triangles.length; i < n; ++i) {\n        triangle = triangles[i];\n        triangle.previous = triangles[i - 1];\n        triangle.next = triangles[i + 1];\n      }\n    });\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the area of the current point is less than that of the previous point\n      // to be eliminated, use the latter's area instead. This ensures that the\n      // current point cannot be eliminated without eliminating previously-\n      // eliminated points.\n      if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;\n      else maxArea = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    topology.arcs.forEach(function(arc) {\n      arc.forEach(relative);\n    });\n\n    function update(triangle) {\n      heap.remove(triangle);\n      triangle[1][2] = triangleArea(triangle);\n      heap.push(triangle);\n    }\n\n    return topology;\n  };\n\n  function cartesianRingArea(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n\n    while (++i < n) {\n      a = b;\n      b = ring[i];\n      area += a[0] * b[1] - a[1] * b[0];\n    }\n\n    return area * .5;\n  }\n\n  function cartesianTriangleArea(triangle) {\n    var a = triangle[0], b = triangle[1], c = triangle[2];\n    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));\n  }\n\n  function compareArea(a, b) {\n    return a[1][2] - b[1][2];\n  }\n\n  function minAreaHeap() {\n    var heap = {},\n        array = [],\n        size = 0;\n\n    heap.push = function(object) {\n      up(array[object._ = size] = object, size++);\n      return size;\n    };\n\n    heap.pop = function() {\n      if (size <= 0) return;\n      var removed = array[0], object;\n      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n      return removed;\n    };\n\n    heap.remove = function(removed) {\n      var i = removed._, object;\n      if (array[i] !== removed) return; // invalid request\n      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n      return i;\n    };\n\n    function up(object, i) {\n      while (i > 0) {\n        var j = ((i + 1) >> 1) - 1,\n            parent = array[j];\n        if (compareArea(object, parent) >= 0) break;\n        array[parent._ = i] = parent;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    function down(object, i) {\n      while (true) {\n        var r = (i + 1) << 1,\n            l = r - 1,\n            j = i,\n            child = array[j];\n        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];\n        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];\n        if (j === i) break;\n        array[child._ = i] = child;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    return heap;\n  }\n\n  function transformAbsolute(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      point[0] = (x0 += point[0]) * kx + dx;\n      point[1] = (y0 += point[1]) * ky + dy;\n    };\n  }\n\n  function transformRelative(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      var x1 = (point[0] - dx) / kx | 0,\n          y1 = (point[1] - dy) / ky | 0;\n      point[0] = x1 - x0;\n      point[1] = y1 - y0;\n      x0 = x1;\n      y0 = y1;\n    };\n  }\n\n  function noop() {}\n\n  if (typeof define === \"function\" && define.amd) define(topojson);\n  else if (typeof module === \"object\" && module.exports) module.exports = topojson;\n  else this.topojson = topojson;\n}();\n"]}