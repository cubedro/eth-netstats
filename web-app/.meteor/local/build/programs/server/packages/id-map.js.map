{"version":3,"sources":["id-map/id-map.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,yC;AACA,kB;AACA,iB;AACA,oD;AACA,wC;AACA,E;;AAEA,4E;AACA,6E;AACA,6E;AACA,gD;;AAEA,2B;AACA,sB;AACA,oB;AACA,oC;AACA,0B;AACA,I;AACA,6B;AACA,oB;AACA,oC;AACA,2B;AACA,I;AACA,yB;AACA,oB;AACA,oC;AACA,0B;AACA,I;AACA,sB;AACA,oB;AACA,oC;AACA,iC;AACA,I;AACA,sB;AACA,oB;AACA,gC;AACA,I;AACA,sB;AACA,oB;AACA,mB;AACA,I;AACA,0E;AACA,gC;AACA,oB;AACA,0D;AACA,iC;AACA,2C;AACA,gE;AACA,+D;AACA,iC;AACA,e;AACA,K;AACA,I;AACA,qB;AACA,oB;AACA,6B;AACA,I;AACA,kC;AACA,oB;AACA,oC;AACA,8B;AACA,4B;AACA,yB;AACA,e;AACA,I;AACA,6E;AACA,0D;AACA,sB;AACA,oB;AACA,4D;AACA,uC;AACA,wC;AACA,O;AACA,iB;AACA,G;AACA,G","file":"/packages/id-map.js","sourcesContent":["IdMap = function (idStringify, idParse) {\n  var self = this;\n  self._map = {};\n  self._idStringify = idStringify || JSON.stringify;\n  self._idParse = idParse || JSON.parse;\n};\n\n// Some of these methods are designed to match methods on OrderedDict, since\n// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably.\n// (Conceivably, this should be replaced with \"UnorderedDict\" with a specific\n// set of methods that overlap between the two.)\n\n_.extend(IdMap.prototype, {\n  get: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    return self._map[key];\n  },\n  set: function (id, value) {\n    var self = this;\n    var key = self._idStringify(id);\n    self._map[key] = value;\n  },\n  remove: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    delete self._map[key];\n  },\n  has: function (id) {\n    var self = this;\n    var key = self._idStringify(id);\n    return _.has(self._map, key);\n  },\n  empty: function () {\n    var self = this;\n    return _.isEmpty(self._map);\n  },\n  clear: function () {\n    var self = this;\n    self._map = {};\n  },\n  // Iterates over the items in the map. Return `false` to break the loop.\n  forEach: function (iterator) {\n    var self = this;\n    // don't use _.each, because we can't break out of it.\n    var keys = _.keys(self._map);\n    for (var i = 0; i < keys.length; i++) {\n      var breakIfFalse = iterator.call(null, self._map[keys[i]],\n                                       self._idParse(keys[i]));\n      if (breakIfFalse === false)\n        return;\n    }\n  },\n  size: function () {\n    var self = this;\n    return _.size(self._map);\n  },\n  setDefault: function (id, def) {\n    var self = this;\n    var key = self._idStringify(id);\n    if (_.has(self._map, key))\n      return self._map[key];\n    self._map[key] = def;\n    return def;\n  },\n  // Assumes that values are EJSON-cloneable, and that we don't need to clone\n  // IDs (ie, that nobody is going to mutate an ObjectId).\n  clone: function () {\n    var self = this;\n    var clone = new IdMap(self._idStringify, self._idParse);\n    self.forEach(function (value, id) {\n      clone.set(id, EJSON.clone(value));\n    });\n    return clone;\n  }\n});\n\n"]}