{"version":3,"sources":["retry/retry.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,2C;AACA,E;AACA,W;AACA,yD;AACA,kE;AACA,kD;AACA,sD;AACA,mE;AACA,qE;;AAEA,4B;AACA,kB;AACA,qD;AACA,kC;AACA,kB;AACA,oE;AACA,8B;AACA,uC;AACA,mB;AACA,gB;AACA,uB;AACA,M;AACA,yB;AACA,E;;AAEA,2B;;AAEA,mC;AACA,sB;AACA,oB;AACA,wB;AACA,oC;AACA,2B;AACA,I;;AAEA,sE;AACA,oC;AACA,8B;AACA,oB;;AAEA,8B;AACA,6B;;AAEA,2B;AACA,sB;AACA,yD;AACA,kE;AACA,wB;AACA,0D;AACA,4C;AACA,mB;AACA,I;;AAEA,0E;AACA,oC;AACA,oB;AACA,uC;AACA,wB;AACA,oC;AACA,qD;AACA,mB;AACA,G;;AAEA,G","file":"/packages/retry.js","sourcesContent":["// Retry logic with an exponential backoff.\n//\n// options:\n//  baseTimeout: time for initial reconnect attempt (ms).\n//  exponent: exponential factor to increase timeout each attempt.\n//  maxTimeout: maximum time between retries (ms).\n//  minCount: how many times to reconnect \"instantly\".\n//  minTimeout: time to wait for the first `minCount` retries (ms).\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\n\nRetry = function (options) {\n  var self = this;\n  _.extend(self, _.defaults(_.clone(options || {}), {\n    baseTimeout: 1000, // 1 second\n    exponent: 2.2,\n    // The default is high-ish to ensure a server can recover from a\n    // failure caused by load.\n    maxTimeout: 5 * 60000, // 5 minutes\n    minTimeout: 10,\n    minCount: 2,\n    fuzz: 0.5 // +- 25%\n  }));\n  self.retryTimer = null;\n};\n\n_.extend(Retry.prototype, {\n\n  // Reset a pending retry, if any.\n  clear: function () {\n    var self = this;\n    if (self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = null;\n  },\n\n  // Calculate how long to wait in milliseconds to retry, based on the\n  // `count` of which retry this is.\n  _timeout: function (count) {\n    var self = this;\n\n    if (count < self.minCount)\n      return self.minTimeout;\n\n    var timeout = Math.min(\n      self.maxTimeout,\n      self.baseTimeout * Math.pow(self.exponent, count));\n    // fuzz the timeout randomly, to avoid reconnect storms when a\n    // server goes down.\n    timeout = timeout * ((Random.fraction() * self.fuzz) +\n                         (1 - self.fuzz/2));\n    return timeout;\n  },\n\n  // Call `fn` after a delay, based on the `count` of which retry this is.\n  retryLater: function (count, fn) {\n    var self = this;\n    var timeout = self._timeout(count);\n    if (self.retryTimer)\n      clearTimeout(self.retryTimer);\n    self.retryTimer = Meteor.setTimeout(fn, timeout);\n    return timeout;\n  }\n\n});\n"]}