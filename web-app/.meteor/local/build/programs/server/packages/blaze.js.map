{"version":3,"sources":["blaze/preamble.js","blaze/exceptions.js","blaze/view.js","blaze/builtins.js","blaze/lookup.js","blaze/template.js","blaze/backcompat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,mB;AACA,oE;AACA,G;AACA,W;;AAEA,iE;AACA,6B;AACA,oB;AACA,gB;AACA,gB;AACA,kB;AACA,kB;AACA,kE;AACA,gB;AACA,I;AACA,gC;AACA,yB;AACA,I;;AAEA,uB;AACA,8C;AACA,I;AACA,K;;AAEA,8B;AACA,0B;;AAEA,sD;AACA,oD;AACA,2D;AACA,qB;AACA,E;;;;;;;;;;;;;;;;;;;AChCA,c;;AAEA,2E;AACA,8E;AACA,4E;AACA,sB;AACA,E;AACA,S;AACA,E;AACA,M;AACA,Q;AACA,yB;AACA,gB;AACA,0B;AACA,I;AACA,M;AACA,E;AACA,6D;;AAEA,yD;AACA,wD;AACA,iD;AACA,kC;;AAEA,4C;AACA,kC;AACA,sC;AACA,Y;AACA,G;;AAEA,kB;AACA,2B;AACA,6B;AACA,6D;AACA,8E;AACA,gC;AACA,M;;AAEA,4E;AACA,gF;AACA,gE;AACA,4E;AACA,E;;AAEA,qD;AACA,8B;AACA,a;;AAEA,sB;AACA,S;AACA,sC;AACA,iB;AACA,+D;AACA,K;AACA,I;AACA,E;;;;;;;;;;;;;;;;;;;ACvDA,0C;AACA,G;AACA,iE;AACA,2B;AACA,G;AACA,uE;AACA,uE;AACA,G;AACA,oE;AACA,gE;AACA,iC;AACA,G;AACA,kE;AACA,+D;AACA,8C;AACA,G;AACA,iE;AACA,4D;AACA,G;AACA,iE;AACA,oE;AACA,+D;AACA,yE;AACA,iE;AACA,6C;AACA,G;AACA,2B;AACA,G;AACA,oE;AACA,mE;AACA,mE;AACA,gE;AACA,sE;AACA,0E;;AAEA,G;AACA,S;AACA,8E;AACA,gB;AACA,kG;AACA,wJ;AACA,G;AACA,sC;AACA,qC;AACA,2B;AACA,wC;;AAEA,mC;AACA,8B;AACA,kB;AACA,c;AACA,G;AACA,mB;AACA,wB;;AAEA,qB;AACA,kB;AACA,mB;AACA,mB;AACA,I;;AAEA,yD;AACA,0D;AACA,kD;AACA,yB;AACA,sC;AACA,0B;AACA,2B;AACA,2B;AACA,2B;AACA,yB;AACA,wB;AACA,+E;AACA,2E;AACA,a;AACA,+E;AACA,8E;AACA,8E;AACA,6E;AACA,+E;AACA,mC;;AAEA,uB;AACA,E;;AAEA,4D;;AAEA,oD;AACA,0D;AACA,mC;AACA,E;;AAEA,sD;AACA,4D;AACA,oC;AACA,E;;AAEA,kD;AACA,kB;AACA,0B;AACA,oC;AACA,+B;AACA,kD;AACA,wB;AACA,W;AACA,O;AACA,O;AACA,I;AACA,kD;AACA,yB;AACA,a;AACA,kC;AACA,sC;AACA,Q;AACA,a;AACA,K;AACA,E;;AAEA,sD;AACA,8D;AACA,qC;AACA,E;;AAEA,sB;AACA,G;AACA,kE;AACA,6D;AACA,2D;AACA,iE;AACA,gE;AACA,4C;AACA,G;AACA,+D;AACA,qE;AACA,uE;AACA,8C;AACA,G;AACA,6C;AACA,0E;AACA,6D;AACA,6D;AACA,oC;AACA,wE;AACA,kB;;AAEA,qE;AACA,sE;AACA,mE;AACA,qE;AACA,0E;AACA,+C;AACA,I;AACA,qE;AACA,iE;AACA,sE;AACA,iE;AACA,iE;AACA,kE;AACA,0B;AACA,I;AACA,uE;AACA,oE;AACA,yE;AACA,oE;AACA,uE;AACA,0B;AACA,yB;AACA,6F;AACA,G;AACA,yB;AACA,0H;AACA,G;AACA,uB;AACA,gI;AACA,G;;AAEA,uE;AACA,6E;AACA,8E;AACA,+E;AACA,uB;AACA,6E;AACA,8E;AACA,6C;AACA,kB;AACA,4E;;AAEA,sC;AACA,qE;AACA,gG;AACA,+B;AACA,S;AACA,O;AACA,I;;AAEA,yE;AACA,gF;AACA,+E;AACA,wB;AACA,oE;AACA,uC;;AAEA,yD;;AAEA,kB;AACA,E;;AAEA,kE;AACA,kB;;AAEA,yB;AACA,+F;AACA,G;AACA,yB;AACA,4H;AACA,G;AACA,yB;AACA,gI;AACA,G;AACA,E;;AAEA,G;AACA,qE;AACA,qE;AACA,4E;AACA,0C;AACA,G;AACA,2D;AACA,kB;AACA,0B;;AAEA,uC;;AAEA,gB;AACA,2B;AACA,6E;AACA,U;AACA,qD;AACA,G;;AAEA,oC;AACA,qB;AACA,K;;AAEA,mB;AACA,E;;AAEA,8C;AACA,yB;AACA,sE;;AAEA,oC;AACA,E;;AAEA,6C;AACA,yB;AACA,sE;;AAEA,mC;AACA,E;;AAEA,+C;AACA,4C;AACA,kD;AACA,uC;AACA,0D;AACA,0B;AACA,O;AACA,K;AACA,E;;AAEA,+D;AACA,qB;AACA,wD;;AAEA,yC;AACA,wB;AACA,mB;AACA,uC;;AAEA,wC;AACA,E;;AAEA,qD;AACA,qD;AACA,4B;AACA,uB;AACA,yB;AACA,yC;;AAEA,0B;;AAEA,yD;AACA,4B;;AAEA,gE;AACA,oC;AACA,wD;AACA,S;AACA,K;;AAEA,gC;AACA,oC;AACA,wC;AACA,wB;AACA,K;;AAEA,kB;AACA,E;;AAEA,iE;AACA,+D;AACA,qD;AACA,E;AACA,oE;AACA,mE;AACA,oE;AACA,sE;AACA,kE;AACA,4D;AACA,qE;AACA,0C;AACA,8E;AACA,sC;;AAEA,e;AACA,iB;AACA,qE;AACA,iC;AACA,mC;AACA,uC;AACA,8C;AACA,yB;AACA,8B;AACA,sE;AACA,wB;AACA,kC;AACA,+B;;AAEA,yB;AACA,sD;AACA,sB;AACA,uE;AACA,4D;AACA,gD;AACA,mD;AACA,W;AACA,W;AACA,O;AACA,0B;;AAEA,sE;AACA,mE;AACA,kE;AACA,wD;AACA,wC;AACA,uB;AACA,oC;AACA,S;AACA,S;AACA,iC;;AAEA,qD;AACA,wB;AACA,uB;AACA,oE;AACA,sD;AACA,+E;AACA,Y;AACA,mE;AACA,qE;AACA,gE;AACA,+D;AACA,kE;AACA,sE;AACA,2D;AACA,2B;AACA,yD;AACA,mC;AACA,wD;AACA,2E;AACA,kC;AACA,S;AACA,0D;AACA,2D;AACA,K;AACA,K;;AAEA,qB;AACA,oB;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,gE;AACA,oE;AACA,gE;AACA,yE;AACA,mE;AACA,oE;AACA,gE;AACA,oE;AACA,Y;AACA,iD;AACA,6D;;AAEA,0B;AACA,yD;AACA,0B;AACA,K;AACA,2B;;AAEA,2C;;AAEA,uB;AACA,sC;AACA,+B;AACA,O;AACA,U;AACA,6B;AACA,G;;AAEA,gB;AACA,E;;AAEA,wB;AACA,0D;AACA,2B;AACA,6B;AACA,oC;AACA,4B;AACA,gC;AACA,mD;;AAEA,+D;AACA,wE;AACA,I;AACA,qC;AACA,gC;AACA,oC;AACA,6D;;AAEA,2D;AACA,gF;AACA,I;AACA,+C;AACA,uE;AACA,yD;AACA,oC;AACA,6D;;AAEA,kE;AACA,8B;AACA,G;AACA,G;;AAEA,6D;AACA,wC;AACA,0C;AACA,+B;AACA,kD;AACA,E;;AAEA,+C;AACA,sD;AACA,oC;AACA,6C;AACA,E;;AAEA,wD;AACA,sD;AACA,oC;AACA,sD;AACA,E;;AAEA,kD;AACA,uB;AACA,W;AACA,0B;;AAEA,0C;;AAEA,4D;AACA,+D;AACA,iE;;AAEA,qB;AACA,8C;AACA,E;;AAEA,sC;AACA,0B;AACA,qD;AACA,E;;AAEA,6D;AACA,+D;AACA,S;AACA,yC;AACA,8B;AACA,4D;AACA,yB;AACA,uB;AACA,U;AACA,uB;AACA,6D;AACA,gC;AACA,G;AACA,E;;AAEA,G;AACA,oI;AACA,gB;AACA,qB;AACA,G;AACA,yB;;AAEA,gD;AACA,kC;AACA,O;AACA,6B;AACA,kB;AACA,a;AACA,gC;AACA,G;AACA,E;;AAEA,oD;AACA,qE;AACA,oE;AACA,U;AACA,6C;AACA,uB;AACA,yC;AACA,qC;AACA,8C;;AAEA,wC;AACA,4C;AACA,sC;AACA,W;;AAEA,O;AACA,iE;AACA,0D;AACA,4B;AACA,sC;AACA,e;AACA,iD;AACA,iD;AACA,G;AACA,E;;AAEA,sD;AACA,kD;AACA,oB;AACA,wC;AACA,8B;;AAEA,0C;AACA,mC;AACA,6C;AACA,mB;AACA,U;AACA,uB;AACA,qC;AACA,0B;AACA,uB;AACA,Q;AACA,K;AACA,sC;AACA,G;AACA,E;;AAEA,kE;AACA,6D;AACA,gB;AACA,wC;AACA,8B;;AAEA,sC;AACA,wB;AACA,qB;AACA,M;AACA,U;AACA,mB;AACA,G;AACA,E;;AAEA,G;AACA,iL;AACA,gB;AACA,qR;AACA,sH;AACA,6N;AACA,kI;AACA,G;AACA,wE;AACA,wB;AACA,yE;AACA,0E;AACA,G;;AAEA,uC;AACA,8B;AACA,0B;AACA,oB;AACA,G;;AAEA,kE;AACA,sE;AACA,4C;AACA,kE;AACA,0D;AACA,kF;AACA,qD;;AAEA,sD;;AAEA,oC;AACA,2C;;AAEA,sB;AACA,mD;AACA,G;;AAEA,c;AACA,E;;AAEA,yD;AACA,iF;AACA,+D;;AAEA,8D;AACA,oE;;AAEA,iD;AACA,E;;AAEA,G;AACA,gH;AACA,gB;AACA,kH;AACA,2J;AACA,sH;AACA,6N;AACA,kI;AACA,G;AACA,sF;AACA,iF;AACA,6C;AACA,wE;AACA,+D;AACA,E;;AAEA,G;AACA,0G;AACA,gB;AACA,mG;AACA,G;AACA,gC;AACA,8D;AACA,oE;;AAEA,gB;AACA,6B;AACA,iC;AACA,gD;AACA,uB;AACA,sB;AACA,K;;AAEA,uD;AACA,G;AACA,E;;AAEA,G;AACA,2D;AACA,gB;AACA,oI;AACA,G;AACA,+C;AACA,sD;;AAEA,4E;AACA,E;;AAEA,G;AACA,2G;AACA,gB;AACA,oI;AACA,iG;AACA,G;AACA,6D;AACA,sD;;AAEA,2D;AACA,gD;AACA,E;;AAEA,yD;AACA,mC;AACA,0E;;AAEA,qE;AACA,kC;AACA,0B;AACA,sB;AACA,G;AACA,sD;;AAEA,iB;AACA,yC;AACA,6C;AACA,6C;AACA,+C;AACA,qD;;AAEA,kE;AACA,E;;AAEA,G;AACA,uJ;AACA,gB;AACA,iH;AACA,G;AACA,0C;AACA,c;;AAEA,wB;AACA,oC;AACA,mD;AACA,6B;AACA,4C;AACA,4C;AACA,0D;AACA,qC;AACA,8C;AACA,mD;AACA,U;AACA,oD;AACA,G;;AAEA,gD;AACA,E;;AAEA,kB;AACA,2C;AACA,iE;AACA,iD;;AAEA,6B;AACA,4C;;AAEA,gC;AACA,E;;AAEA,+B;;AAEA,G;AACA,sF;AACA,gB;AACA,mG;AACA,G;AACA,qD;AACA,2B;;AAEA,4C;AACA,8C;AACA,6B;AACA,yB;AACA,G;;AAEA,8D;AACA,6C;AACA,wB;AACA,2C;AACA,mD;AACA,yD;AACA,0D;AACA,0D;AACA,U;AACA,oD;AACA,G;AACA,E;;AAEA,wD;AACA,U;AACA,yC;AACA,+B;AACA,wD;AACA,6D;AACA,4D;AACA,qD;AACA,a;AACA,gD;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,6D;AACA,yB;AACA,gB;AACA,G;AACA,E;;AAEA,8C;AACA,0B;;AAEA,a;AACA,gC;AACA,uB;AACA,G;;AAEA,mB;AACA,E;;AAEA,+C;AACA,+C;AACA,kB;AACA,2B;AACA,gC;AACA,iB;AACA,4B;AACA,kC;AACA,U;AACA,gE;AACA,K;AACA,G;;AAEA,a;AACA,sC;AACA,6B;AACA,wB;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,+D;AACA,0C;AACA,mB;;AAEA,uB;AACA,iD;;AAEA,yE;AACA,+C;AACA,uC;AACA,wE;AACA,yC;AACA,wC;AACA,+B;AACA,iB;;AAEA,sC;AACA,uC;AACA,gD;AACA,uC;AACA,0B;AACA,2D;AACA,0B;AACA,oD;AACA,wC;AACA,6D;AACA,6D;AACA,e;AACA,Y;AACA,+B;AACA,iC;AACA,c;AACA,S;AACA,O;AACA,K;;AAEA,oC;AACA,kC;AACA,e;AACA,O;AACA,uB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACp3BA,6C;AACA,iD;AACA,iB;AACA,iB;AACA,E;;AAEA,G;AACA,uE;AACA,gB;AACA,wK;AACA,qG;AACA,G;AACA,2C;AACA,6C;;AAEA,iC;;AAEA,kC;AACA,qC;AACA,sC;AACA,gC;AACA,iC;AACA,qC;AACA,Y;AACA,6B;AACA,K;AACA,K;;AAEA,c;AACA,E;;AAEA,G;AACA,iE;AACA,gB;AACA,wM;AACA,qG;AACA,sL;AACA,G;AACA,kE;AACA,qC;;AAEA,6D;AACA,+C;AACA,qC;AACA,K;AACA,qC;AACA,kC;AACA,8B;AACA,4D;AACA,+C;AACA,qC;AACA,K;;AAEA,c;AACA,E;;AAEA,G;AACA,gD;AACA,gB;AACA,wL;AACA,qG;AACA,sL;AACA,G;AACA,gE;AACA,uE;AACA,E;;AAEA,G;AACA,qF;AACA,gB;AACA,8H;AACA,qG;AACA,yK;AACA,G;AACA,wD;AACA,iD;AACA,wC;AACA,gC;AACA,sC;AACA,qD;AACA,qC;AACA,K;AACA,oB;AACA,K;AACA,gC;AACA,wB;AACA,8B;AACA,6B;AACA,qC;AACA,+B;AACA,oC;;AAEA,sC;AACA,qD;AACA,gE;AACA,oD;AACA,kC;AACA,qC;AACA,0C;;AAEA,+D;AACA,mC;AACA,Q;AACA,2C;AACA,yC;AACA,mE;AACA,8B;;AAEA,0C;AACA,gD;AACA,0C;AACA,sC;AACA,iD;AACA,0C;AACA,a;;AAEA,sE;AACA,uD;AACA,kB;AACA,mE;AACA,W;AACA,W;AACA,Q;AACA,6C;AACA,yC;AACA,8B;AACA,0C;AACA,gD;AACA,0C;AACA,mD;AACA,+D;AACA,yC;AACA,2C;AACA,uC;AACA,4D;AACA,gC;AACA,a;AACA,kB;AACA,sD;AACA,W;AACA,W;AACA,Q;AACA,yD;AACA,yC;AACA,0C;AACA,gD;AACA,kB;AACA,yB;AACA,qC;AACA,kE;AACA,oB;AACA,yD;AACA,a;AACA,0C;AACA,W;AACA,W;AACA,Q;AACA,wD;AACA,yC;AACA,0C;AACA,gD;AACA,0C;AACA,8D;AACA,kB;AACA,oD;AACA,+C;AACA,0C;AACA,kD;AACA,W;AACA,W;AACA,O;AACA,O;;AAEA,uD;AACA,iC;AACA,mC;AACA,mD;AACA,K;AACA,K;;AAEA,wC;AACA,4B;AACA,iC;AACA,K;;AAEA,kB;AACA,E;;AAEA,mD;AACA,Q;;AAEA,oB;AACA,kC;AACA,2B;AACA,iB;AACA,M;AACA,G;;AAEA,+E;AACA,6E;AACA,6E;AACA,4E;AACA,0D;AACA,4E;AACA,qE;AACA,iC;AACA,I;AACA,0E;AACA,mE;AACA,oC;AACA,iC;AACA,uE;AACA,0D;AACA,K;AACA,4B;AACA,gE;AACA,Y;AACA,uB;AACA,K;AACA,I;;AAEA,wC;AACA,yC;;AAEA,mE;AACA,yE;AACA,sD;AACA,4C;AACA,wC;AACA,K;AACA,wC;AACA,yC;AACA,K;;AAEA,mB;AACA,I;;AAEA,qD;AACA,4B;AACA,W;AACA,E;;AAEA,oE;AACA,6D;AACA,2C;;AAEA,iE;AACA,oE;AACA,qE;AACA,qE;AACA,kC;AACA,uC;;AAEA,kC;AACA,8C;AACA,iC;AACA,K;AACA,c;AACA,E;;AAEA,wB;AACA,yD;;;;;;;;;;;;;;;;;;;ACrQA,0B;;AAEA,yC;AACA,qE;AACA,8C;AACA,oC;AACA,E;;AAEA,6C;AACA,8B;AACA,a;AACA,2B;AACA,E;;AAEA,oE;AACA,+B;AACA,oC;AACA,gC;AACA,wB;AACA,iC;AACA,uB;AACA,kB;AACA,sC;AACA,M;AACA,G;AACA,W;AACA,E;;AAEA,4B;;AAEA,8E;AACA,0B;AACA,oC;;AAEA,qC;AACA,8C;AACA,4C;AACA,mC;AACA,Y;AACA,oB;AACA,K;AACA,G;;AAEA,qB;AACA,yB;AACA,gC;AACA,kC;AACA,2D;AACA,gD;AACA,yE;AACA,gF;AACA,+C;AACA,O;AACA,K;AACA,0B;AACA,G;;AAEA,c;AACA,E;;AAEA,6C;AACA,gC;AACA,a;AACA,G;;AAEA,sB;AACA,oB;AACA,yB;;AAEA,+E;AACA,mF;AACA,O;AACA,I;AACA,E;;AAEA,0D;AACA,6D;AACA,4D;AACA,uD;AACA,wD;AACA,2D;AACA,mC;AACA,E;AACA,yD;AACA,kD;AACA,E;AACA,sD;AACA,0D;AACA,0C;AACA,yD;AACA,+B;AACA,qD;AACA,a;AACA,wB;;AAEA,8B;AACA,4D;AACA,G;;AAEA,yB;AACA,mE;AACA,0C;AACA,8B;AACA,uE;;AAEA,yE;;AAEA,wB;AACA,sE;AACA,kE;AACA,0D;AACA,gE;AACA,gC;AACA,kD;AACA,kE;AACA,yB;AACA,U;AACA,wB;AACA,sD;AACA,iC;AACA,qD;AACA,qD;AACA,O;AACA,yD;AACA,qD;AACA,O;AACA,iB;AACA,oB;AACA,yB;AACA,oC;AACA,iC;AACA,2D;AACA,S;AACA,iB;AACA,O;AACA,sC;AACA,M;AACA,G;AACA,c;AACA,E;;AAEA,kC;AACA,6C;AACA,yD;AACA,uE;AACA,uB;AACA,e;AACA,G;AACA,sC;AACA,iD;AACA,6C;AACA,G;;AAEA,gB;AACA,gB;AACA,uB;AACA,yD;AACA,+B;AACA,E;;;AAGA,uD;AACA,4C;AACA,E;;;;;;;;;;;;;;;;;;;ACnKA,mD;AACA,E;AACA,qE;AACA,0C;AACA,E;AACA,sE;AACA,2B;;AAEA,G;AACA,S;AACA,0G;AACA,gB;AACA,uH;AACA,+L;AACA,G;AACA,sD;AACA,yC;AACA,2B;AACA,wD;;AAEA,uC;AACA,kC;AACA,8B;AACA,kB;AACA,G;AACA,mC;AACA,8D;AACA,2C;AACA,yD;;AAEA,2B;AACA,uC;;AAEA,iC;AACA,wB;;AAEA,qB;AACA,gB;AACA,iB;AACA,iB;AACA,I;AACA,E;AACA,8B;;AAEA,+B;AACA,2C;AACA,wB;AACA,E;AACA,mD;AACA,0B;AACA,E;AACA,2C;AACA,4B;AACA,E;;AAEA,G;AACA,oF;AACA,gB;AACA,wC;AACA,G;AACA,iC;AACA,uC;AACA,E;;AAEA,G;AACA,mB;AACA,Y;AACA,qB;AACA,0F;AACA,mE;AACA,gB;AACA,G;AACA,8C;AACA,mC;AACA,E;;AAEA,G;AACA,oB;AACA,Y;AACA,qB;AACA,wG;AACA,mE;AACA,gB;AACA,G;AACA,+C;AACA,oC;AACA,E;;AAEA,G;AACA,qB;AACA,Y;AACA,qB;AACA,qH;AACA,mE;AACA,gB;AACA,G;AACA,gD;AACA,qC;AACA,E;;AAEA,qD;AACA,kB;AACA,mD;AACA,sE;AACA,mE;AACA,6B;AACA,uD;AACA,mB;AACA,E;;AAEA,oD;AACA,qC;AACA,qC;AACA,iB;AACA,yD;AACA,oC;AACA,O;AACA,O;AACA,E;;AAEA,qE;AACA,kB;AACA,4D;AACA,uB;;AAEA,+B;AACA,sE;AACA,4B;AACA,6D;;AAEA,4D;AACA,sC;AACA,iC;AACA,e;;AAEA,yE;AACA,oE;AACA,yE;AACA,mE;AACA,kE;AACA,sE;AACA,mD;AACA,0D;AACA,O;;AAEA,6C;AACA,0C;AACA,S;AACA,O;AACA,G;;AAEA,4D;AACA,uC;AACA,4E;AACA,c;AACA,sC;;AAEA,O;AACA,gB;AACA,uC;AACA,kB;AACA,sE;AACA,oB;AACA,O;AACA,oC;;AAEA,8C;AACA,kD;AACA,gD;AACA,Y;AACA,uE;AACA,4B;AACA,2B;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,mB;AACA,c;AACA,uB;AACA,2E;AACA,kB;AACA,uB;AACA,K;AACA,qE;AACA,yE;AACA,iD;AACA,uD;AACA,kC;AACA,6D;AACA,K;;AAEA,K;AACA,oB;AACA,c;AACA,uB;AACA,4E;AACA,kB;AACA,uB;AACA,K;AACA,yD;AACA,gC;AACA,8D;AACA,K;;AAEA,K;AACA,qB;AACA,c;AACA,uB;AACA,6E;AACA,kB;AACA,uB;AACA,K;AACA,2D;AACA,oC;AACA,+D;AACA,K;;AAEA,c;AACA,E;;AAEA,G;AACA,S;AACA,4C;AACA,2B;AACA,yB;AACA,G;AACA,0C;AACA,iD;AACA,2B;AACA,4C;;AAEA,qC;AACA,qC;;AAEA,gC;;AAEA,K;AACA,e;AACA,qC;AACA,c;AACA,iF;AACA,kB;AACA,uB;AACA,K;AACA,mB;AACA,mB;;AAEA,K;AACA,oB;AACA,qC;AACA,c;AACA,qE;AACA,kB;AACA,oB;AACA,K;AACA,wB;;AAEA,K;AACA,mB;AACA,qC;AACA,c;AACA,oE;AACA,kB;AACA,oB;AACA,K;AACA,uB;;AAEA,6D;AACA,yD;AACA,+E;AACA,8E;AACA,uC;AACA,mD;AACA,6B;;AAEA,iC;AACA,E;;AAEA,G;AACA,gH;AACA,gB;AACA,uF;AACA,uB;AACA,G;AACA,0D;AACA,uB;AACA,uB;AACA,oE;AACA,oC;AACA,E;;AAEA,G;AACA,4E;AACA,gB;AACA,uF;AACA,0B;AACA,G;AACA,gE;AACA,sD;AACA,E;;AAEA,G;AACA,2E;AACA,gB;AACA,uF;AACA,wB;AACA,G;AACA,6D;AACA,gC;AACA,2B;AACA,E;;AAEA,G;AACA,4G;AACA,gB;AACA,yG;AACA,G;AACA,yD;AACA,8B;AACA,E;;AAEA,G;AACA,8E;AACA,kC;AACA,yE;AACA,2E;AACA,8E;AACA,sB;AACA,gB;AACA,0E;AACA,6B;AACA,8E;AACA,a;AACA,0E;AACA,2E;AACA,wC;AACA,G;AACA,yE;AACA,kB;;AAEA,6C;AACA,kC;;AAEA,0C;AACA,qB;AACA,oB;AACA,iC;AACA,kC;AACA,qC;AACA,2B;AACA,sE;AACA,+C;AACA,qE;AACA,wB;AACA,6B;AACA,K;AACA,G;;AAEA,gB;AACA,oC;AACA,uC;AACA,0E;AACA,6D;AACA,gD;;AAEA,+E;AACA,gF;AACA,c;AACA,+B;AACA,sC;AACA,K;;AAEA,qB;AACA,wB;AACA,K;AACA,I;AACA,uB;;AAEA,wD;;AAEA,sD;AACA,qD;;AAEA,8E;AACA,4E;AACA,a;AACA,6B;AACA,sC;AACA,K;AACA,G;;AAEA,mB;AACA,E;;AAEA,G;AACA,+E;AACA,uE;AACA,4E;AACA,S;AACA,G;AACA,mE;AACA,iC;;AAEA,2E;AACA,0B;AACA,K;;AAEA,4B;AACA,E;;AAEA,G;AACA,gE;AACA,gB;AACA,kE;AACA,G;AACA,8C;AACA,qB;AACA,mC;AACA,E;;AAEA,gE;AACA,6D;AACA,+E;AACA,uE;AACA,a;AACA,6C;;AAEA,4E;AACA,iC;AACA,uD;AACA,kE;AACA,O;AACA,iE;AACA,kB;AACA,a;AACA,gE;AACA,G;AACA,E;;AAEA,G;AACA,qD;AACA,gB;AACA,6E;AACA,G;AACA,iD;AACA,sB;AACA,qB;AACA,2B;AACA,qC;AACA,wC;AACA,oD;AACA,sD;AACA,yB;AACA,oB;AACA,yD;AACA,mE;AACA,8C;;AAEA,iF;AACA,qC;AACA,W;AACA,Q;AACA,uB;AACA,G;;AAEA,uC;AACA,E;;AAEA,G;AACA,Y;AACA,iB;AACA,qB;AACA,mK;AACA,gB;AACA,oC;AACA,G;AACA,iC;AACA,8C;AACA,+C;AACA,E;;AAEA,qE;AACA,uC;;AAEA,G;AACA,W;AACA,E;AACA,4E;AACA,oC;AACA,+E;AACA,kC;AACA,+E;AACA,Y;AACA,E;AACA,mD;AACA,gB;AACA,Y;AACA,G;AACA,qC;;AAEA,G;AACA,+E;AACA,gB;AACA,Y;AACA,4G;AACA,G;AACA,wC;;AAEA,G;AACA,gG;AACA,gB;AACA,Y;AACA,yE;AACA,yD;AACA,G;AACA,+C;;;;;;;;;;;;;;;;;;;ACtgBA,W;;AAEA,gC;AACA,+C;;AAEA,gB;AACA,iD;;AAEA,mC;;AAEA,qE;AACA,iC;AACA,0C;AACA,uB;AACA,E;AACA,uD;AACA,gC;AACA,E","file":"/packages/blaze.js","sourcesContent":["/**\n * @namespace Blaze\n * @summary The namespace for all Blaze-related methods and classes.\n */\nBlaze = {};\n\n// Utility to HTML-escape a string.  Included for legacy reasons.\nBlaze._escape = (function() {\n  var escape_map = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\n    \"&\": \"&amp;\"\n  };\n  var escape_one = function(c) {\n    return escape_map[c];\n  };\n\n  return function (x) {\n    return x.replace(/[&<>\"'`]/g, escape_one);\n  };\n})();\n\nBlaze._warn = function (msg) {\n  msg = 'Warning: ' + msg;\n\n  if ((typeof Log !== 'undefined') && Log && Log.warn)\n    Log.warn(msg); // use Meteor's \"logging\" package\n  else if ((typeof console !== 'undefined') && console.log)\n    console.log(msg);\n};\n","var debugFunc;\n\n// We call into user code in many places, and it's nice to catch exceptions\n// propagated from user code immediately so that the whole system doesn't just\n// break.  Catching exceptions is easy; reporting them is hard.  This helper\n// reports exceptions.\n//\n// Usage:\n//\n// ```\n// try {\n//   // ... someStuff ...\n// } catch (e) {\n//   reportUIException(e);\n// }\n// ```\n//\n// An optional second argument overrides the default message.\n\n// Set this to `true` to cause `reportException` to throw\n// the next exception rather than reporting it.  This is\n// useful in unit tests that test error messages.\nBlaze._throwNextException = false;\n\nBlaze._reportException = function (e, msg) {\n  if (Blaze._throwNextException) {\n    Blaze._throwNextException = false;\n    throw e;\n  }\n\n  if (! debugFunc)\n    // adapted from Tracker\n    debugFunc = function () {\n      return (typeof Meteor !== \"undefined\" ? Meteor._debug :\n              ((typeof console !== \"undefined\") && console.log ? console.log :\n               function () {}));\n    };\n\n  // In Chrome, `e.stack` is a multiline string that starts with the message\n  // and contains a stack trace.  Furthermore, `console.log` makes it clickable.\n  // `console.log` supplies the space between the two arguments.\n  debugFunc()(msg || 'Exception caught in template:', e.stack || e.message);\n};\n\nBlaze._wrapCatchingExceptions = function (f, where) {\n  if (typeof f !== 'function')\n    return f;\n\n  return function () {\n    try {\n      return f.apply(this, arguments);\n    } catch (e) {\n      Blaze._reportException(e, 'Exception in ' + where + ':');\n    }\n  };\n};\n","/// [new] Blaze.View([name], renderMethod)\n///\n/// Blaze.View is the building block of reactive DOM.  Views have\n/// the following features:\n///\n/// * lifecycle callbacks - Views are created, rendered, and destroyed,\n///   and callbacks can be registered to fire when these things happen.\n///\n/// * parent pointer - A View points to its parentView, which is the\n///   View that caused it to be rendered.  These pointers form a\n///   hierarchy or tree of Views.\n///\n/// * render() method - A View's render() method specifies the DOM\n///   (or HTML) content of the View.  If the method establishes\n///   reactive dependencies, it may be re-run.\n///\n/// * a DOMRange - If a View is rendered to DOM, its position and\n///   extent in the DOM are tracked using a DOMRange object.\n///\n/// When a View is constructed by calling Blaze.View, the View is\n/// not yet considered \"created.\"  It doesn't have a parentView yet,\n/// and no logic has been run to initialize the View.  All real\n/// work is deferred until at least creation time, when the onViewCreated\n/// callbacks are fired, which happens when the View is \"used\" in\n/// some way that requires it to be rendered.\n///\n/// ...more lifecycle stuff\n///\n/// `name` is an optional string tag identifying the View.  The only\n/// time it's used is when looking in the View tree for a View of a\n/// particular name; for example, data contexts are stored on Views\n/// of name \"with\".  Names are also useful when debugging, so in\n/// general it's good for functions that create Views to set the name.\n/// Views associated with templates have names of the form \"Template.foo\".\n\n/**\n * @class\n * @summary Constructor for a View, which represents a reactive region of DOM.\n * @locus Client\n * @param {String} [name] Optional.  A name for this type of View.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#renderable_content).  In this function, `this` is bound to the View.\n */\nBlaze.View = function (name, render) {\n  if (! (this instanceof Blaze.View))\n    // called without `new`\n    return new Blaze.View(name, render);\n\n  if (typeof name === 'function') {\n    // omitted \"name\" argument\n    render = name;\n    name = '';\n  }\n  this.name = name;\n  this._render = render;\n\n  this._callbacks = {\n    created: null,\n    rendered: null,\n    destroyed: null\n  };\n\n  // Setting all properties here is good for readability,\n  // and also may help Chrome optimize the code by keeping\n  // the View object from changing shape too much.\n  this.isCreated = false;\n  this._isCreatedForExpansion = false;\n  this.isRendered = false;\n  this._isAttached = false;\n  this.isDestroyed = false;\n  this._isInRender = false;\n  this.parentView = null;\n  this._domrange = null;\n  // This flag is normally set to false except for the cases when view's parent\n  // was generated as part of expanding some syntactic sugar expressions or\n  // methods.\n  // Ex.: Blaze.renderWithData is an equivalent to creating a view with regular\n  // Blaze.render and wrapping it into {{#with data}}{{/with}} view. Since the\n  // users don't know anything about these generated parent views, Blaze needs\n  // this information to be available on views to make smarter decisions. For\n  // example: removing the generated parent view with the view on Blaze.remove.\n  this._hasGeneratedParent = false;\n\n  this.renderCount = 0;\n};\n\nBlaze.View.prototype._render = function () { return null; };\n\nBlaze.View.prototype.onViewCreated = function (cb) {\n  this._callbacks.created = this._callbacks.created || [];\n  this._callbacks.created.push(cb);\n};\n\nBlaze.View.prototype._onViewRendered = function (cb) {\n  this._callbacks.rendered = this._callbacks.rendered || [];\n  this._callbacks.rendered.push(cb);\n};\n\nBlaze.View.prototype.onViewReady = function (cb) {\n  var self = this;\n  var fire = function () {\n    Tracker.afterFlush(function () {\n      if (! self.isDestroyed) {\n        Blaze._withCurrentView(self, function () {\n          cb.call(self);\n        });\n      }\n    });\n  };\n  self._onViewRendered(function onViewRendered() {\n    if (self.isDestroyed)\n      return;\n    if (! self._domrange.attached)\n      self._domrange.onAttached(fire);\n    else\n      fire();\n  });\n};\n\nBlaze.View.prototype.onViewDestroyed = function (cb) {\n  this._callbacks.destroyed = this._callbacks.destroyed || [];\n  this._callbacks.destroyed.push(cb);\n};\n\n/// View#autorun(func)\n///\n/// Sets up a Tracker autorun that is \"scoped\" to this View in two\n/// important ways: 1) Blaze.currentView is automatically set\n/// on every re-run, and 2) the autorun is stopped when the\n/// View is destroyed.  As with Tracker.autorun, the first run of\n/// the function is immediate, and a Computation object that can\n/// be used to stop the autorun is returned.\n///\n/// View#autorun is meant to be called from View callbacks like\n/// onViewCreated, or from outside the rendering process.  It may not\n/// be called before the onViewCreated callbacks are fired (too early),\n/// or from a render() method (too confusing).\n///\n/// Typically, autoruns that update the state\n/// of the View (as in Blaze.With) should be started from an onViewCreated\n/// callback.  Autoruns that update the DOM should be started\n/// from either onViewCreated (guarded against the absence of\n/// view._domrange), or onViewReady.\nBlaze.View.prototype.autorun = function (f, _inViewScope, displayName) {\n  var self = this;\n\n  // The restrictions on when View#autorun can be called are in order\n  // to avoid bad patterns, like creating a Blaze.View and immediately\n  // calling autorun on it.  A freshly created View is not ready to\n  // have logic run on it; it doesn't have a parentView, for example.\n  // It's when the View is materialized or expanded that the onViewCreated\n  // handlers are fired and the View starts up.\n  //\n  // Letting the render() method call `this.autorun()` is problematic\n  // because of re-render.  The best we can do is to stop the old\n  // autorun and start a new one for each render, but that's a pattern\n  // we try to avoid internally because it leads to helpers being\n  // called extra times, in the case where the autorun causes the\n  // view to re-render (and thus the autorun to be torn down and a\n  // new one established).\n  //\n  // We could lift these restrictions in various ways.  One interesting\n  // idea is to allow you to call `view.autorun` after instantiating\n  // `view`, and automatically wrap it in `view.onViewCreated`, deferring\n  // the autorun so that it starts at an appropriate time.  However,\n  // then we can't return the Computation object to the caller, because\n  // it doesn't exist yet.\n  if (! self.isCreated) {\n    throw new Error(\"View#autorun must be called from the created callback at the earliest\");\n  }\n  if (this._isInRender) {\n    throw new Error(\"Can't call View#autorun from inside render(); try calling it from the created or rendered callback\");\n  }\n  if (Tracker.active) {\n    throw new Error(\"Can't call View#autorun from a Tracker Computation; try calling it from the created or rendered callback\");\n  }\n\n  // Each local variable allocate additional space on each frame of the\n  // execution stack. When too many variables are allocated on stack, you can\n  // run out of memory on stack running a deep recursion (which is typical for\n  // Blaze functions) and get stackoverlow error. (The size of the stack varies\n  // between browsers).\n  // The trick we use here is to allocate only one variable on stack `locals`\n  // that keeps references to all the rest. Since locals is allocated on heap,\n  // we don't take up any space on the stack.\n  var locals = {};\n  locals.templateInstanceFunc = Blaze.Template._currentTemplateInstanceFunc;\n\n  locals.f = function viewAutorun(c) {\n    return Blaze._withCurrentView(_inViewScope || self, function () {\n      return Blaze.Template._withTemplateInstanceFunc(locals.templateInstanceFunc, function () {\n        return f.call(self, c);\n      });\n    });\n  };\n\n  // Give the autorun function a better name for debugging and profiling.\n  // The `displayName` property is not part of the spec but browsers like Chrome\n  // and Firefox prefer it in debuggers over the name function was declared by.\n  locals.f.displayName =\n    (self.name || 'anonymous') + ':' + (displayName || 'anonymous');\n  locals.c = Tracker.autorun(locals.f);\n\n  self.onViewDestroyed(function () { locals.c.stop(); });\n\n  return locals.c;\n};\n\nBlaze.View.prototype._errorIfShouldntCallSubscribe = function () {\n  var self = this;\n\n  if (! self.isCreated) {\n    throw new Error(\"View#subscribe must be called from the created callback at the earliest\");\n  }\n  if (self._isInRender) {\n    throw new Error(\"Can't call View#subscribe from inside render(); try calling it from the created or rendered callback\");\n  }\n  if (self.isDestroyed) {\n    throw new Error(\"Can't call View#subscribe from inside the destroyed callback, try calling it inside created or rendered.\");\n  }\n};\n\n/**\n * Just like Blaze.View#autorun, but with Meteor.subscribe instead of\n * Tracker.autorun. Stop the subscription when the view is destroyed.\n * @return {SubscriptionHandle} A handle to the subscription so that you can\n * see if it is ready, or stop it manually\n */\nBlaze.View.prototype.subscribe = function (args, options) {\n  var self = this;\n  options = {} || options;\n\n  self._errorIfShouldntCallSubscribe();\n\n  var subHandle;\n  if (options.connection) {\n    subHandle = options.connection.subscribe.apply(options.connection, args);\n  } else {\n    subHandle = Meteor.subscribe.apply(Meteor, args);\n  }\n\n  self.onViewDestroyed(function () {\n    subHandle.stop();\n  });\n\n  return subHandle;\n};\n\nBlaze.View.prototype.firstNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.firstNode();\n};\n\nBlaze.View.prototype.lastNode = function () {\n  if (! this._isAttached)\n    throw new Error(\"View must be attached before accessing its DOM\");\n\n  return this._domrange.lastNode();\n};\n\nBlaze._fireCallbacks = function (view, which) {\n  Blaze._withCurrentView(view, function () {\n    Tracker.nonreactive(function fireCallbacks() {\n      var cbs = view._callbacks[which];\n      for (var i = 0, N = (cbs && cbs.length); i < N; i++)\n        cbs[i].call(view);\n    });\n  });\n};\n\nBlaze._createView = function (view, parentView, forExpansion) {\n  if (view.isCreated)\n    throw new Error(\"Can't render the same View twice\");\n\n  view.parentView = (parentView || null);\n  view.isCreated = true;\n  if (forExpansion)\n    view._isCreatedForExpansion = true;\n\n  Blaze._fireCallbacks(view, 'created');\n};\n\nvar doFirstRender = function (view, initialContent) {\n  var domrange = new Blaze._DOMRange(initialContent);\n  view._domrange = domrange;\n  domrange.view = view;\n  view.isRendered = true;\n  Blaze._fireCallbacks(view, 'rendered');\n\n  var teardownHook = null;\n\n  domrange.onAttached(function attached(range, element) {\n    view._isAttached = true;\n\n    teardownHook = Blaze._DOMBackend.Teardown.onElementTeardown(\n      element, function teardown() {\n        Blaze._destroyView(view, true /* _skipNodes */);\n      });\n  });\n\n  // tear down the teardown hook\n  view.onViewDestroyed(function () {\n    teardownHook && teardownHook.stop();\n    teardownHook = null;\n  });\n\n  return domrange;\n};\n\n// Take an uncreated View `view` and create and render it to DOM,\n// setting up the autorun that updates the View.  Returns a new\n// DOMRange, which has been associated with the View.\n//\n// The private arguments `_workStack` and `_intoArray` are passed in\n// by Blaze._materializeDOM.  If provided, then we avoid the mutual\n// recursion of calling back into Blaze._materializeDOM so that deep\n// View hierarchies don't blow the stack.  Instead, we push tasks onto\n// workStack for the initial rendering and subsequent setup of the\n// View, and they are done after we return.  When there is a\n// _workStack, we do not return the new DOMRange, but instead push it\n// into _intoArray from a _workStack task.\nBlaze._materializeView = function (view, parentView, _workStack, _intoArray) {\n  Blaze._createView(view, parentView);\n\n  var domrange;\n  var lastHtmljs;\n  // We don't expect to be called in a Computation, but just in case,\n  // wrap in Tracker.nonreactive.\n  Tracker.nonreactive(function () {\n    view.autorun(function doRender(c) {\n      // `view.autorun` sets the current view.\n      view.renderCount++;\n      view._isInRender = true;\n      // Any dependencies that should invalidate this Computation come\n      // from this line:\n      var htmljs = view._render();\n      view._isInRender = false;\n\n      if (! c.firstRun) {\n        Tracker.nonreactive(function doMaterialize() {\n          // re-render\n          var rangesAndNodes = Blaze._materializeDOM(htmljs, [], view);\n          if (! Blaze._isContentEqual(lastHtmljs, htmljs)) {\n            domrange.setMembers(rangesAndNodes);\n            Blaze._fireCallbacks(view, 'rendered');\n          }\n        });\n      }\n      lastHtmljs = htmljs;\n\n      // Causes any nested views to stop immediately, not when we call\n      // `setMembers` the next time around the autorun.  Otherwise,\n      // helpers in the DOM tree to be replaced might be scheduled\n      // to re-run before we have a chance to stop them.\n      Tracker.onInvalidate(function () {\n        if (domrange) {\n          domrange.destroyMembers();\n        }\n      });\n    }, undefined, 'materialize');\n\n    // first render.  lastHtmljs is the first htmljs.\n    var initialContents;\n    if (! _workStack) {\n      initialContents = Blaze._materializeDOM(lastHtmljs, [], view);\n      domrange = doFirstRender(view, initialContents);\n      initialContents = null; // help GC because we close over this scope a lot\n    } else {\n      // We're being called from Blaze._materializeDOM, so to avoid\n      // recursion and save stack space, provide a description of the\n      // work to be done instead of doing it.  Tasks pushed onto\n      // _workStack will be done in LIFO order after we return.\n      // The work will still be done within a Tracker.nonreactive,\n      // because it will be done by some call to Blaze._materializeDOM\n      // (which is always called in a Tracker.nonreactive).\n      initialContents = [];\n      // push this function first so that it happens last\n      _workStack.push(function () {\n        domrange = doFirstRender(view, initialContents);\n        initialContents = null; // help GC because of all the closures here\n        _intoArray.push(domrange);\n      });\n      // now push the task that calculates initialContents\n      _workStack.push([lastHtmljs, initialContents, view]);\n    }\n  });\n\n  if (! _workStack) {\n    return domrange;\n  } else {\n    return null;\n  }\n};\n\n// Expands a View to HTMLjs, calling `render` recursively on all\n// Views and evaluating any dynamic attributes.  Calls the `created`\n// callback, but not the `materialized` or `rendered` callbacks.\n// Destroys the view immediately, unless called in a Tracker Computation,\n// in which case the view will be destroyed when the Computation is\n// invalidated.  If called in a Tracker Computation, the result is a\n// reactive string; that is, the Computation will be invalidated\n// if any changes are made to the view or subviews that might affect\n// the HTML.\nBlaze._expandView = function (view, parentView) {\n  Blaze._createView(view, parentView, true /*forExpansion*/);\n\n  view._isInRender = true;\n  var htmljs = Blaze._withCurrentView(view, function () {\n    return view._render();\n  });\n  view._isInRender = false;\n\n  var result = Blaze._expand(htmljs, view);\n\n  if (Tracker.active) {\n    Tracker.onInvalidate(function () {\n      Blaze._destroyView(view);\n    });\n  } else {\n    Blaze._destroyView(view);\n  }\n\n  return result;\n};\n\n// Options: `parentView`\nBlaze._HTMLJSExpander = HTML.TransformingVisitor.extend();\nBlaze._HTMLJSExpander.def({\n  visitObject: function (x) {\n    if (x instanceof Blaze.Template)\n      x = x.constructView();\n    if (x instanceof Blaze.View)\n      return Blaze._expandView(x, this.parentView);\n\n    // this will throw an error; other objects are not allowed!\n    return HTML.TransformingVisitor.prototype.visitObject.call(this, x);\n  },\n  visitAttributes: function (attrs) {\n    // expand dynamic attributes\n    if (typeof attrs === 'function')\n      attrs = Blaze._withCurrentView(this.parentView, attrs);\n\n    // call super (e.g. for case where `attrs` is an array)\n    return HTML.TransformingVisitor.prototype.visitAttributes.call(this, attrs);\n  },\n  visitAttribute: function (name, value, tag) {\n    // expand attribute values that are functions.  Any attribute value\n    // that contains Views must be wrapped in a function.\n    if (typeof value === 'function')\n      value = Blaze._withCurrentView(this.parentView, value);\n\n    return HTML.TransformingVisitor.prototype.visitAttribute.call(\n      this, name, value, tag);\n  }\n});\n\n// Return Blaze.currentView, but only if it is being rendered\n// (i.e. we are in its render() method).\nvar currentViewIfRendering = function () {\n  var view = Blaze.currentView;\n  return (view && view._isInRender) ? view : null;\n};\n\nBlaze._expand = function (htmljs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visit(htmljs);\n};\n\nBlaze._expandAttributes = function (attrs, parentView) {\n  parentView = parentView || currentViewIfRendering();\n  return (new Blaze._HTMLJSExpander(\n    {parentView: parentView})).visitAttributes(attrs);\n};\n\nBlaze._destroyView = function (view, _skipNodes) {\n  if (view.isDestroyed)\n    return;\n  view.isDestroyed = true;\n\n  Blaze._fireCallbacks(view, 'destroyed');\n\n  // Destroy views and elements recursively.  If _skipNodes,\n  // only recurse up to views, not elements, for the case where\n  // the backend (jQuery) is recursing over the elements already.\n\n  if (view._domrange)\n    view._domrange.destroyMembers(_skipNodes);\n};\n\nBlaze._destroyNode = function (node) {\n  if (node.nodeType === 1)\n    Blaze._DOMBackend.Teardown.tearDownElement(node);\n};\n\n// Are the HTMLjs entities `a` and `b` the same?  We could be\n// more elaborate here but the point is to catch the most basic\n// cases.\nBlaze._isContentEqual = function (a, b) {\n  if (a instanceof HTML.Raw) {\n    return (b instanceof HTML.Raw) && (a.value === b.value);\n  } else if (a == null) {\n    return (b == null);\n  } else {\n    return (a === b) &&\n      ((typeof a === 'number') || (typeof a === 'boolean') ||\n       (typeof a === 'string'));\n  }\n};\n\n/**\n * @summary The View corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client\n * @type {Blaze.View}\n */\nBlaze.currentView = null;\n\nBlaze._withCurrentView = function (view, func) {\n  var oldView = Blaze.currentView;\n  try {\n    Blaze.currentView = view;\n    return func();\n  } finally {\n    Blaze.currentView = oldView;\n  }\n};\n\n// Blaze.render publicly takes a View or a Template.\n// Privately, it takes any HTMLJS (extended with Views and Templates)\n// except null or undefined, or a function that returns any extended\n// HTMLJS.\nvar checkRenderContent = function (content) {\n  if (content === null)\n    throw new Error(\"Can't render null\");\n  if (typeof content === 'undefined')\n    throw new Error(\"Can't render undefined\");\n\n  if ((content instanceof Blaze.View) ||\n      (content instanceof Blaze.Template) ||\n      (typeof content === 'function'))\n    return;\n\n  try {\n    // Throw if content doesn't look like HTMLJS at the top level\n    // (i.e. verify that this is an HTML.Tag, or an array,\n    // or a primitive, etc.)\n    (new HTML.Visitor).visit(content);\n  } catch (e) {\n    // Make error message suitable for public API\n    throw new Error(\"Expected Template or View\");\n  }\n};\n\n// For Blaze.render and Blaze.toHTML, take content and\n// wrap it in a View, unless it's a single View or\n// Template already.\nvar contentAsView = function (content) {\n  checkRenderContent(content);\n\n  if (content instanceof Blaze.Template) {\n    return content.constructView();\n  } else if (content instanceof Blaze.View) {\n    return content;\n  } else {\n    var func = content;\n    if (typeof func !== 'function') {\n      func = function () {\n        return content;\n      };\n    }\n    return Blaze.View('render', func);\n  }\n};\n\n// For Blaze.renderWithData and Blaze.toHTMLWithData, wrap content\n// in a function, if necessary, so it can be a content arg to\n// a Blaze.With.\nvar contentAsFunc = function (content) {\n  checkRenderContent(content);\n\n  if (typeof content !== 'function') {\n    return function () {\n      return content;\n    };\n  } else {\n    return content;\n  }\n};\n\n/**\n * @summary Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered [View](#blaze_view) which can be passed to [`Blaze.remove`](#blaze_remove).\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.  If a template, a View object is [constructed](#template_constructview).  If a View, it must be an unrendered View, which becomes a rendered View and is returned.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.render = function (content, parentElement, nextNode, parentView) {\n  if (! parentElement) {\n    Blaze._warn(\"Blaze.render without a parent element is deprecated. \" +\n                \"You must specify where to insert the rendered content.\");\n  }\n\n  if (nextNode instanceof Blaze.View) {\n    // handle omitted nextNode\n    parentView = nextNode;\n    nextNode = null;\n  }\n\n  // parentElement must be a DOM node. in particular, can't be the\n  // result of a call to `$`. Can't check if `parentElement instanceof\n  // Node` since 'Node' is undefined in IE8.\n  if (parentElement && typeof parentElement.nodeType !== 'number')\n    throw new Error(\"'parentElement' must be a DOM node\");\n  if (nextNode && typeof nextNode.nodeType !== 'number') // 'nextNode' is optional\n    throw new Error(\"'nextNode' must be a DOM node\");\n\n  parentView = parentView || currentViewIfRendering();\n\n  var view = contentAsView(content);\n  Blaze._materializeView(view, parentView);\n\n  if (parentElement) {\n    view._domrange.attach(parentElement, nextNode);\n  }\n\n  return view;\n};\n\nBlaze.insert = function (view, parentElement, nextNode) {\n  Blaze._warn(\"Blaze.insert has been deprecated.  Specify where to insert the \" +\n              \"rendered content in the call to Blaze.render.\");\n\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  view._domrange.attach(parentElement, nextNode);\n};\n\n/**\n * @summary Renders a template or View to DOM nodes with a data context.  Otherwise identical to `Blaze.render`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object to render.\n * @param {Object|Function} data The data context to use, or a function returning a data context.  If a function is provided, it will be reactively re-run.\n * @param {DOMNode} parentNode The node that will be the parent of the rendered template.  It must be an Element node.\n * @param {DOMNode} [nextNode] Optional. If provided, must be a child of <em>parentNode</em>; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.\n * @param {Blaze.View} [parentView] Optional. If provided, it will be set as the rendered View's [`parentView`](#view_parentview).\n */\nBlaze.renderWithData = function (content, data, parentElement, nextNode, parentView) {\n  // We defer the handling of optional arguments to Blaze.render.  At this point,\n  // `nextNode` may actually be `parentView`.\n  return Blaze.render(Blaze._TemplateWith(data, contentAsFunc(content)),\n                          parentElement, nextNode, parentView);\n};\n\n/**\n * @summary Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it.\n * @locus Client\n * @param {Blaze.View} renderedView The return value from `Blaze.render` or `Blaze.renderWithData`.\n */\nBlaze.remove = function (view) {\n  if (! (view && (view._domrange instanceof Blaze._DOMRange)))\n    throw new Error(\"Expected template rendered with Blaze.render\");\n\n  while (view) {\n    if (! view.isDestroyed) {\n      var range = view._domrange;\n      if (range.attached && ! range.parentRange)\n        range.detach();\n      range.destroy();\n    }\n\n    view = view._hasGeneratedParent && view.parentView;\n  }\n};\n\n/**\n * @summary Renders a template or View to a string of HTML.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n */\nBlaze.toHTML = function (content, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(contentAsView(content), parentView));\n};\n\n/**\n * @summary Renders a template or View to HTML with a data context.  Otherwise identical to `Blaze.toHTML`.\n * @locus Client\n * @param {Template|Blaze.View} templateOrView The template (e.g. `Template.myTemplate`) or View object from which to generate HTML.\n * @param {Object|Function} data The data context to use, or a function returning a data context.\n */\nBlaze.toHTMLWithData = function (content, data, parentView) {\n  parentView = parentView || currentViewIfRendering();\n\n  return HTML.toHTML(Blaze._expandView(Blaze._TemplateWith(\n    data, contentAsFunc(content)), parentView));\n};\n\nBlaze._toText = function (htmljs, parentView, textMode) {\n  if (typeof htmljs === 'function')\n    throw new Error(\"Blaze._toText doesn't take a function, just HTMLjs\");\n\n  if ((parentView != null) && ! (parentView instanceof Blaze.View)) {\n    // omitted parentView argument\n    textMode = parentView;\n    parentView = null;\n  }\n  parentView = parentView || currentViewIfRendering();\n\n  if (! textMode)\n    throw new Error(\"textMode required\");\n  if (! (textMode === HTML.TEXTMODE.STRING ||\n         textMode === HTML.TEXTMODE.RCDATA ||\n         textMode === HTML.TEXTMODE.ATTRIBUTE))\n    throw new Error(\"Unknown textMode: \" + textMode);\n\n  return HTML.toText(Blaze._expand(htmljs, parentView), textMode);\n};\n\n/**\n * @summary Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.\n * @locus Client\n * @param {DOMElement|Blaze.View} [elementOrView] Optional.  An element that was rendered by a Meteor, or a View.\n */\nBlaze.getData = function (elementOrView) {\n  var theWith;\n\n  if (! elementOrView) {\n    theWith = Blaze.getView('with');\n  } else if (elementOrView instanceof Blaze.View) {\n    var view = elementOrView;\n    theWith = (view.name === 'with' ? view :\n               Blaze.getView(view, 'with'));\n  } else if (typeof elementOrView.nodeType === 'number') {\n    if (elementOrView.nodeType !== 1)\n      throw new Error(\"Expected DOM element\");\n    theWith = Blaze.getView(elementOrView, 'with');\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n\n  return theWith ? theWith.dataVar.get() : null;\n};\n\n// For back-compat\nBlaze.getElementData = function (element) {\n  Blaze._warn(\"Blaze.getElementData has been deprecated.  Use \" +\n              \"Blaze.getData(element) instead.\");\n\n  if (element.nodeType !== 1)\n    throw new Error(\"Expected DOM element\");\n\n  return Blaze.getData(element);\n};\n\n// Both arguments are optional.\n\n/**\n * @summary Gets either the current View, or the View enclosing the given DOM element.\n * @locus Client\n * @param {DOMElement} [element] Optional.  If specified, the View enclosing `element` is returned.\n */\nBlaze.getView = function (elementOrView, _viewName) {\n  var viewName = _viewName;\n\n  if ((typeof elementOrView) === 'string') {\n    // omitted elementOrView; viewName present\n    viewName = elementOrView;\n    elementOrView = null;\n  }\n\n  // We could eventually shorten the code by folding the logic\n  // from the other methods into this method.\n  if (! elementOrView) {\n    return Blaze._getCurrentView(viewName);\n  } else if (elementOrView instanceof Blaze.View) {\n    return Blaze._getParentView(elementOrView, viewName);\n  } else if (typeof elementOrView.nodeType === 'number') {\n    return Blaze._getElementView(elementOrView, viewName);\n  } else {\n    throw new Error(\"Expected DOM element or View\");\n  }\n};\n\n// Gets the current view or its nearest ancestor of name\n// `name`.\nBlaze._getCurrentView = function (name) {\n  var view = Blaze.currentView;\n  // Better to fail in cases where it doesn't make sense\n  // to use Blaze._getCurrentView().  There will be a current\n  // view anywhere it does.  You can check Blaze.currentView\n  // if you want to know whether there is one or not.\n  if (! view)\n    throw new Error(\"There is no current view\");\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    // Blaze._getCurrentView() with no arguments just returns\n    // Blaze.currentView.\n    return view;\n  }\n};\n\nBlaze._getParentView = function (view, name) {\n  var v = view.parentView;\n\n  if (name) {\n    while (v && v.name !== name)\n      v = v.parentView;\n  }\n\n  return v || null;\n};\n\nBlaze._getElementView = function (elem, name) {\n  var range = Blaze._DOMRange.forElement(elem);\n  var view = null;\n  while (range && ! view) {\n    view = (range.view || null);\n    if (! view) {\n      if (range.parentRange)\n        range = range.parentRange;\n      else\n        range = Blaze._DOMRange.forElement(range.parentElement);\n    }\n  }\n\n  if (name) {\n    while (view && view.name !== name)\n      view = view.parentView;\n    return view || null;\n  } else {\n    return view;\n  }\n};\n\nBlaze._addEventMap = function (view, eventMap, thisInHandler) {\n  thisInHandler = (thisInHandler || null);\n  var handles = [];\n\n  if (! view._domrange)\n    throw new Error(\"View must have a DOMRange\");\n\n  view._domrange.onAttached(function attached_eventMaps(range, element) {\n    _.each(eventMap, function (handler, spec) {\n      var clauses = spec.split(/,\\s+/);\n      // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\n      _.each(clauses, function (clause) {\n        var parts = clause.split(/\\s+/);\n        if (parts.length === 0)\n          return;\n\n        var newEvents = parts.shift();\n        var selector = parts.join(' ');\n        handles.push(Blaze._EventSupport.listen(\n          element, newEvents, selector,\n          function (evt) {\n            if (! range.containsElement(evt.currentTarget))\n              return null;\n            var handlerThis = thisInHandler || this;\n            var handlerArgs = arguments;\n            return Blaze._withCurrentView(view, function () {\n              return handler.apply(handlerThis, handlerArgs);\n            });\n          },\n          range, function (r) {\n            return r.parentRange;\n          }));\n      });\n    });\n  });\n\n  view.onViewDestroyed(function () {\n    _.each(handles, function (h) {\n      h.stop();\n    });\n    handles.length = 0;\n  });\n};\n","Blaze._calculateCondition = function (cond) {\n  if (cond instanceof Array && cond.length === 0)\n    cond = false;\n  return !! cond;\n};\n\n/**\n * @summary Constructs a View that renders content with a data context.\n * @locus Client\n * @param {Object|Function} data An object to use as the data context, or a function returning such an object.  If a function is provided, it will be reactively re-run.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n */\nBlaze.With = function (data, contentFunc) {\n  var view = Blaze.View('with', contentFunc);\n\n  view.dataVar = new ReactiveVar;\n\n  view.onViewCreated(function () {\n    if (typeof data === 'function') {\n      // `data` is a reactive function\n      view.autorun(function () {\n        view.dataVar.set(data());\n      }, view.parentView, 'setData');\n    } else {\n      view.dataVar.set(data);\n    }\n  });\n\n  return view;\n};\n\n/**\n * @summary Constructs a View that renders content conditionally.\n * @locus Client\n * @param {Function} conditionFunc A function to reactively re-run.  Whether the result is truthy or falsy determines whether `contentFunc` or `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#renderable_content).  If no `elseFunc` is supplied, no content is shown in the \"else\" case.\n */\nBlaze.If = function (conditionFunc, contentFunc, elseFunc, _not) {\n  var conditionVar = new ReactiveVar;\n\n  var view = Blaze.View(_not ? 'unless' : 'if', function () {\n    return conditionVar.get() ? contentFunc() :\n      (elseFunc ? elseFunc() : null);\n  });\n  view.__conditionVar = conditionVar;\n  view.onViewCreated(function () {\n    this.autorun(function () {\n      var cond = Blaze._calculateCondition(conditionFunc());\n      conditionVar.set(_not ? (! cond) : cond);\n    }, this.parentView, 'condition');\n  });\n\n  return view;\n};\n\n/**\n * @summary An inverted [`Blaze.If`](#blaze_if).\n * @locus Client\n * @param {Function} conditionFunc A function to reactively re-run.  If the result is falsy, `contentFunc` is shown, otherwise `elseFunc` is shown.  An empty array is considered falsy.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#renderable_content).  If no `elseFunc` is supplied, no content is shown in the \"else\" case.\n */\nBlaze.Unless = function (conditionFunc, contentFunc, elseFunc) {\n  return Blaze.If(conditionFunc, contentFunc, elseFunc, true /*_not*/);\n};\n\n/**\n * @summary Constructs a View that renders `contentFunc` for each item in a sequence.\n * @locus Client\n * @param {Function} argFunc A function to reactively re-run.  The function may return a Cursor, an array, null, or undefined.\n * @param {Function} contentFunc A Function that returns [*renderable content*](#renderable_content).\n * @param {Function} [elseFunc] Optional.  A Function that returns [*renderable content*](#renderable_content) to display in the case when there are no items to display.\n */\nBlaze.Each = function (argFunc, contentFunc, elseFunc) {\n  var eachView = Blaze.View('each', function () {\n    var subviews = this.initialSubviews;\n    this.initialSubviews = null;\n    if (this._isCreatedForExpansion) {\n      this.expandedValueDep = new Tracker.Dependency;\n      this.expandedValueDep.depend();\n    }\n    return subviews;\n  });\n  eachView.initialSubviews = [];\n  eachView.numItems = 0;\n  eachView.inElseMode = false;\n  eachView.stopHandle = null;\n  eachView.contentFunc = contentFunc;\n  eachView.elseFunc = elseFunc;\n  eachView.argVar = new ReactiveVar;\n\n  eachView.onViewCreated(function () {\n    // We evaluate argFunc in an autorun to make sure\n    // Blaze.currentView is always set when it runs (rather than\n    // passing argFunc straight to ObserveSequence).\n    eachView.autorun(function () {\n      eachView.argVar.set(argFunc());\n    }, eachView.parentView, 'collection');\n\n    eachView.stopHandle = ObserveSequence.observe(function () {\n      return eachView.argVar.get();\n    }, {\n      addedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          var newItemView = Blaze.With(item, eachView.contentFunc);\n          eachView.numItems++;\n\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            if (eachView.inElseMode) {\n              eachView._domrange.removeMember(0);\n              eachView.inElseMode = false;\n            }\n\n            var range = Blaze._materializeView(newItemView, eachView);\n            eachView._domrange.addMember(range, index);\n          } else {\n            eachView.initialSubviews.splice(index, 0, newItemView);\n          }\n        });\n      },\n      removedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          eachView.numItems--;\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            eachView._domrange.removeMember(index);\n            if (eachView.elseFunc && eachView.numItems === 0) {\n              eachView.inElseMode = true;\n              eachView._domrange.addMember(\n                Blaze._materializeView(\n                  Blaze.View('each_else',eachView.elseFunc),\n                  eachView), 0);\n            }\n          } else {\n            eachView.initialSubviews.splice(index, 1);\n          }\n        });\n      },\n      changedAt: function (id, newItem, oldItem, index) {\n        Tracker.nonreactive(function () {\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else {\n            var itemView;\n            if (eachView._domrange) {\n              itemView = eachView._domrange.getMember(index).view;\n            } else {\n              itemView = eachView.initialSubviews[index];\n            }\n            itemView.dataVar.set(newItem);\n          }\n        });\n      },\n      movedTo: function (id, item, fromIndex, toIndex) {\n        Tracker.nonreactive(function () {\n          if (eachView.expandedValueDep) {\n            eachView.expandedValueDep.changed();\n          } else if (eachView._domrange) {\n            eachView._domrange.moveMember(fromIndex, toIndex);\n          } else {\n            var subviews = eachView.initialSubviews;\n            var itemView = subviews[fromIndex];\n            subviews.splice(fromIndex, 1);\n            subviews.splice(toIndex, 0, itemView);\n          }\n        });\n      }\n    });\n\n    if (eachView.elseFunc && eachView.numItems === 0) {\n      eachView.inElseMode = true;\n      eachView.initialSubviews[0] =\n        Blaze.View('each_else', eachView.elseFunc);\n    }\n  });\n\n  eachView.onViewDestroyed(function () {\n    if (eachView.stopHandle)\n      eachView.stopHandle.stop();\n  });\n\n  return eachView;\n};\n\nBlaze._TemplateWith = function (arg, contentFunc) {\n  var w;\n\n  var argFunc = arg;\n  if (typeof arg !== 'function') {\n    argFunc = function () {\n      return arg;\n    };\n  }\n\n  // This is a little messy.  When we compile `{{> Template.contentBlock}}`, we\n  // wrap it in Blaze._InOuterTemplateScope in order to skip the intermediate\n  // parent Views in the current template.  However, when there's an argument\n  // (`{{> Template.contentBlock arg}}`), the argument needs to be evaluated\n  // in the original scope.  There's no good order to nest\n  // Blaze._InOuterTemplateScope and Spacebars.TemplateWith to achieve this,\n  // so we wrap argFunc to run it in the \"original parentView\" of the\n  // Blaze._InOuterTemplateScope.\n  //\n  // To make this better, reconsider _InOuterTemplateScope as a primitive.\n  // Longer term, evaluate expressions in the proper lexical scope.\n  var wrappedArgFunc = function () {\n    var viewToEvaluateArg = null;\n    if (w.parentView && w.parentView.name === 'InOuterTemplateScope') {\n      viewToEvaluateArg = w.parentView.originalParentView;\n    }\n    if (viewToEvaluateArg) {\n      return Blaze._withCurrentView(viewToEvaluateArg, argFunc);\n    } else {\n      return argFunc();\n    }\n  };\n\n  var wrappedContentFunc = function () {\n    var content = contentFunc.call(this);\n\n    // Since we are generating the Blaze._TemplateWith view for the\n    // user, set the flag on the child view.  If `content` is a template,\n    // construct the View so that we can set the flag.\n    if (content instanceof Blaze.Template) {\n      content = content.constructView();\n    }\n    if (content instanceof Blaze.View) {\n      content._hasGeneratedParent = true;\n    }\n\n    return content;\n  };\n\n  w = Blaze.With(wrappedArgFunc, wrappedContentFunc);\n  w.__isTemplateWith = true;\n  return w;\n};\n\nBlaze._InOuterTemplateScope = function (templateView, contentFunc) {\n  var view = Blaze.View('InOuterTemplateScope', contentFunc);\n  var parentView = templateView.parentView;\n\n  // Hack so that if you call `{{> foo bar}}` and it expands into\n  // `{{#with bar}}{{> foo}}{{/with}}`, and then `foo` is a template\n  // that inserts `{{> Template.contentBlock}}`, the data context for\n  // `Template.contentBlock` is not `bar` but the one enclosing that.\n  if (parentView.__isTemplateWith)\n    parentView = parentView.parentView;\n\n  view.onViewCreated(function () {\n    this.originalParentView = this.parentView;\n    this.parentView = parentView;\n  });\n  return view;\n};\n\n// XXX COMPAT WITH 0.9.0\nBlaze.InOuterTemplateScope = Blaze._InOuterTemplateScope;\n","Blaze._globalHelpers = {};\n\n// Documented as Template.registerHelper.\n// This definition also provides back-compat for `UI.registerHelper`.\nBlaze.registerHelper = function (name, func) {\n  Blaze._globalHelpers[name] = func;\n};\n\nvar bindIfIsFunction = function (x, target) {\n  if (typeof x !== 'function')\n    return x;\n  return _.bind(x, target);\n};\n\n// If `x` is a function, binds the value of `this` for that function\n// to the current data context.\nvar bindDataContext = function (x) {\n  if (typeof x === 'function') {\n    return function () {\n      var data = Blaze.getData();\n      if (data == null)\n        data = {};\n      return x.apply(data, arguments);\n    };\n  }\n  return x;\n};\n\nBlaze._OLDSTYLE_HELPER = {};\n\nvar getTemplateHelper = Blaze._getTemplateHelper = function (template, name) {\n  // XXX COMPAT WITH 0.9.3\n  var isKnownOldStyleHelper = false;\n\n  if (template.__helpers.has(name)) {\n    var helper = template.__helpers.get(name);\n    if (helper === Blaze._OLDSTYLE_HELPER) {\n      isKnownOldStyleHelper = true;\n    } else {\n      return helper;\n    }\n  }\n\n  // old-style helper\n  if (name in template) {\n    // Only warn once per helper\n    if (! isKnownOldStyleHelper) {\n      template.__helpers.set(name, Blaze._OLDSTYLE_HELPER);\n      if (! template._NOWARN_OLDSTYLE_HELPERS) {\n        Blaze._warn('Assigning helper with `' + template.viewName + '.' +\n                    name + ' = ...` is deprecated.  Use `' + template.viewName +\n                    '.helpers(...)` instead.');\n      }\n    }\n    return template[name];\n  }\n\n  return null;\n};\n\nvar wrapHelper = function (f, templateFunc) {\n  if (typeof f !== \"function\") {\n    return f;\n  }\n\n  return function () {\n    var self = this;\n    var args = arguments;\n\n    return Blaze.Template._withTemplateInstanceFunc(templateFunc, function () {\n      return Blaze._wrapCatchingExceptions(f, 'template helper').apply(self, args);\n    });\n  };\n};\n\n// Looks up a name, like \"foo\" or \"..\", as a helper of the\n// current template; a global helper; the name of a template;\n// or a property of the data context.  Called on the View of\n// a template (i.e. a View with a `.template` property,\n// where the helpers are).  Used for the first name in a\n// \"path\" in a template tag, like \"foo\" in `{{foo.bar}}` or\n// \"..\" in `{{frobulate ../blah}}`.\n//\n// Returns a function, a non-function value, or null.  If\n// a function is found, it is bound appropriately.\n//\n// NOTE: This function must not establish any reactive\n// dependencies itself.  If there is any reactivity in the\n// value, lookup should return a function.\nBlaze.View.prototype.lookup = function (name, _options) {\n  var template = this.template;\n  var lookupTemplate = _options && _options.template;\n  var helper;\n  var boundTmplInstance;\n\n  if (this.templateInstance) {\n    boundTmplInstance = _.bind(this.templateInstance, this);\n  }\n\n  if (/^\\./.test(name)) {\n    // starts with a dot. must be a series of dots which maps to an\n    // ancestor of the appropriate height.\n    if (!/^(\\.)+$/.test(name))\n      throw new Error(\"id starting with dot must be a series of dots\");\n\n    return Blaze._parentData(name.length - 1, true /*_functionWrapped*/);\n\n  } else if (template &&\n             ((helper = getTemplateHelper(template, name)) != null)) {\n    return wrapHelper(bindDataContext(helper), boundTmplInstance);\n  } else if (lookupTemplate && (name in Blaze.Template) &&\n             (Blaze.Template[name] instanceof Blaze.Template)) {\n    return Blaze.Template[name];\n  } else if (Blaze._globalHelpers[name] != null) {\n    return wrapHelper(bindDataContext(Blaze._globalHelpers[name]),\n      boundTmplInstance);\n  } else {\n    return function () {\n      var isCalledAsFunction = (arguments.length > 0);\n      var data = Blaze.getData();\n      if (lookupTemplate && ! (data && data[name])) {\n        throw new Error(\"No such template: \" + name);\n      }\n      if (isCalledAsFunction && ! (data && data[name])) {\n        throw new Error(\"No such function: \" + name);\n      }\n      if (! data)\n        return null;\n      var x = data[name];\n      if (typeof x !== 'function') {\n        if (isCalledAsFunction) {\n          throw new Error(\"Can't call non-function: \" + x);\n        }\n        return x;\n      }\n      return x.apply(data, arguments);\n    };\n  }\n  return null;\n};\n\n// Implement Spacebars' {{../..}}.\n// @param height {Number} The number of '..'s\nBlaze._parentData = function (height, _functionWrapped) {\n  // If height is null or undefined, we default to 1, the first parent.\n  if (height == null) {\n    height = 1;\n  }\n  var theWith = Blaze.getView('with');\n  for (var i = 0; (i < height) && theWith; i++) {\n    theWith = Blaze.getView(theWith, 'with');\n  }\n\n  if (! theWith)\n    return null;\n  if (_functionWrapped)\n    return function () { return theWith.dataVar.get(); };\n  return theWith.dataVar.get();\n};\n\n\nBlaze.View.prototype.lookupTemplate = function (name) {\n  return this.lookup(name, {template:true});\n};\n","// [new] Blaze.Template([viewName], renderFunction)\n//\n// `Blaze.Template` is the class of templates, like `Template.foo` in\n// Meteor, which is `instanceof Template`.\n//\n// `viewKind` is a string that looks like \"Template.foo\" for templates\n// defined by the compiler.\n\n/**\n * @class\n * @summary Constructor for a Template, which is used to construct Views with particular name and content.\n * @locus Client\n * @param {String} [viewName] Optional.  A name for Views constructed by this Template.  See [`view.name`](#view_name).\n * @param {Function} renderFunction A function that returns [*renderable content*](#renderable_content).  This function is used as the `renderFunction` for Views constructed by this Template.\n */\nBlaze.Template = function (viewName, renderFunction) {\n  if (! (this instanceof Blaze.Template))\n    // called without `new`\n    return new Blaze.Template(viewName, renderFunction);\n\n  if (typeof viewName === 'function') {\n    // omitted \"viewName\" argument\n    renderFunction = viewName;\n    viewName = '';\n  }\n  if (typeof viewName !== 'string')\n    throw new Error(\"viewName must be a String (or omitted)\");\n  if (typeof renderFunction !== 'function')\n    throw new Error(\"renderFunction must be a function\");\n\n  this.viewName = viewName;\n  this.renderFunction = renderFunction;\n\n  this.__helpers = new HelperMap;\n  this.__eventMaps = [];\n\n  this._callbacks = {\n    created: [],\n    rendered: [],\n    destroyed: []\n  };\n};\nvar Template = Blaze.Template;\n\nvar HelperMap = function () {};\nHelperMap.prototype.get = function (name) {\n  return this[' '+name];\n};\nHelperMap.prototype.set = function (name, helper) {\n  this[' '+name] = helper;\n};\nHelperMap.prototype.has = function (name) {\n  return (' '+name) in this;\n};\n\n/**\n * @summary Returns true if `value` is a template object like `Template.myTemplate`.\n * @locus Client\n * @param {Any} value The value to test.\n */\nBlaze.isTemplate = function (t) {\n  return (t instanceof Blaze.Template);\n};\n\n/**\n * @name  onCreated\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is created.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n */\nTemplate.prototype.onCreated = function (cb) {\n  this._callbacks.created.push(cb);\n};\n\n/**\n * @name  onRendered\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is inserted into the DOM.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n */\nTemplate.prototype.onRendered = function (cb) {\n  this._callbacks.rendered.push(cb);\n};\n\n/**\n * @name  onDestroyed\n * @instance\n * @memberOf Template\n * @summary Register a function to be called when an instance of this template is removed from the DOM and destroyed.\n * @param {Function} callback A function to be added as a callback.\n * @locus Client\n */\nTemplate.prototype.onDestroyed = function (cb) {\n  this._callbacks.destroyed.push(cb);\n};\n\nTemplate.prototype._getCallbacks = function (which) {\n  var self = this;\n  var callbacks = self[which] ? [self[which]] : [];\n  // Fire all callbacks added with the new API (Template.onRendered())\n  // as well as the old-style callback (e.g. Template.rendered) for\n  // backwards-compatibility.\n  callbacks = callbacks.concat(self._callbacks[which]);\n  return callbacks;\n};\n\nvar fireCallbacks = function (callbacks, template) {\n  Template._withTemplateInstanceFunc(\n    function () { return template; },\n    function () {\n      for (var i = 0, N = callbacks.length; i < N; i++) {\n        callbacks[i].call(template);\n      }\n    });\n};\n\nTemplate.prototype.constructView = function (contentFunc, elseFunc) {\n  var self = this;\n  var view = Blaze.View(self.viewName, self.renderFunction);\n  view.template = self;\n\n  view.templateContentBlock = (\n    contentFunc ? new Template('(contentBlock)', contentFunc) : null);\n  view.templateElseBlock = (\n    elseFunc ? new Template('(elseBlock)', elseFunc) : null);\n\n  if (self.__eventMaps || typeof self.events === 'object') {\n    view._onViewRendered(function () {\n      if (view.renderCount !== 1)\n        return;\n\n      if (! self.__eventMaps.length && typeof self.events === \"object\") {\n        // Provide limited back-compat support for `.events = {...}`\n        // syntax.  Pass `template.events` to the original `.events(...)`\n        // function.  This code must run only once per template, in\n        // order to not bind the handlers more than once, which is\n        // ensured by the fact that we only do this when `__eventMaps`\n        // is falsy, and we cause it to be set now.\n        Template.prototype.events.call(self, self.events);\n      }\n\n      _.each(self.__eventMaps, function (m) {\n        Blaze._addEventMap(view, m, view);\n      });\n    });\n  }\n\n  view._templateInstance = new Blaze.TemplateInstance(view);\n  view.templateInstance = function () {\n    // Update data, firstNode, and lastNode, and return the TemplateInstance\n    // object.\n    var inst = view._templateInstance;\n\n    /**\n     * @instance\n     * @memberOf Blaze.TemplateInstance\n     * @name  data\n     * @summary The data context of this instance's latest invocation.\n     * @locus Client\n     */\n    inst.data = Blaze.getData(view);\n\n    if (view._domrange && !view.isDestroyed) {\n      inst.firstNode = view._domrange.firstNode();\n      inst.lastNode = view._domrange.lastNode();\n    } else {\n      // on 'created' or 'destroyed' callbacks we don't have a DomRange\n      inst.firstNode = null;\n      inst.lastNode = null;\n    }\n\n    return inst;\n  };\n\n  /**\n   * @name  created\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is created.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  // To avoid situations when new callbacks are added in between view\n  // instantiation and event being fired, decide on all callbacks to fire\n  // immediately and then fire them on the event.\n  var createdCallbacks = self._getCallbacks('created');\n  view.onViewCreated(function () {\n    fireCallbacks(createdCallbacks, view.templateInstance());\n  });\n\n  /**\n   * @name  rendered\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is rendered.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  var renderedCallbacks = self._getCallbacks('rendered');\n  view.onViewReady(function () {\n    fireCallbacks(renderedCallbacks, view.templateInstance());\n  });\n\n  /**\n   * @name  destroyed\n   * @instance\n   * @memberOf Template\n   * @summary Provide a callback when an instance of a template is destroyed.\n   * @locus Client\n   * @deprecated in 1.1\n   */\n  var destroyedCallbacks = self._getCallbacks('destroyed');\n  view.onViewDestroyed(function () {\n    fireCallbacks(destroyedCallbacks, view.templateInstance());\n  });\n\n  return view;\n};\n\n/**\n * @class\n * @summary The class for template instances\n * @param {Blaze.View} view\n * @instanceName template\n */\nBlaze.TemplateInstance = function (view) {\n  if (! (this instanceof Blaze.TemplateInstance))\n    // called without `new`\n    return new Blaze.TemplateInstance(view);\n\n  if (! (view instanceof Blaze.View))\n    throw new Error(\"View required\");\n\n  view._templateInstance = this;\n\n  /**\n   * @name view\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The [View](#blaze_view) object for this invocation of the template.\n   * @locus Client\n   * @type {Blaze.View}\n   */\n  this.view = view;\n  this.data = null;\n\n  /**\n   * @name firstNode\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The first top-level DOM node in this template instance.\n   * @locus Client\n   * @type {DOMNode}\n   */\n  this.firstNode = null;\n\n  /**\n   * @name lastNode\n   * @memberOf Blaze.TemplateInstance\n   * @instance\n   * @summary The last top-level DOM node in this template instance.\n   * @locus Client\n   * @type {DOMNode}\n   */\n  this.lastNode = null;\n\n  // This dependency is used to identify state transitions in\n  // _subscriptionHandles which could cause the result of\n  // TemplateInstance#subscriptionsReady to change. Basically this is triggered\n  // whenever a new subscription handle is added or when a subscription handle\n  // is removed and they are not ready.\n  this._allSubsReadyDep = new Tracker.Dependency();\n  this._allSubsReady = false;\n\n  this._subscriptionHandles = {};\n};\n\n/**\n * @summary Find all elements matching `selector` in this template instance, and return them as a JQuery object.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMNode[]}\n */\nBlaze.TemplateInstance.prototype.$ = function (selector) {\n  var view = this.view;\n  if (! view._domrange)\n    throw new Error(\"Can't use $ on template instance with no DOM\");\n  return view._domrange.$(selector);\n};\n\n/**\n * @summary Find all elements matching `selector` in this template instance.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMElement[]}\n */\nBlaze.TemplateInstance.prototype.findAll = function (selector) {\n  return Array.prototype.slice.call(this.$(selector));\n};\n\n/**\n * @summary Find one element matching `selector` in this template instance.\n * @locus Client\n * @param {String} selector The CSS selector to match, scoped to the template contents.\n * @returns {DOMElement}\n */\nBlaze.TemplateInstance.prototype.find = function (selector) {\n  var result = this.$(selector);\n  return result[0] || null;\n};\n\n/**\n * @summary A version of [Tracker.autorun](#tracker_autorun) that is stopped when the template is destroyed.\n * @locus Client\n * @param {Function} runFunc The function to run. It receives one argument: a Tracker.Computation object.\n */\nBlaze.TemplateInstance.prototype.autorun = function (f) {\n  return this.view.autorun(f);\n};\n\n/**\n * @summary A version of [Meteor.subscribe](#meteor_subscribe) that is stopped\n * when the template is destroyed.\n * @return {SubscriptionHandle} The subscription handle to the newly made\n * subscription. Call `handle.stop()` to manually stop the subscription, or\n * `handle.ready()` to find out if this particular subscription has loaded all\n * of its inital data.\n * @locus Client\n * @param {String} name Name of the subscription.  Matches the name of the\n * server's `publish()` call.\n * @param {Any} [arg1,arg2...] Optional arguments passed to publisher function\n * on server.\n * @param {Function|Object} [callbacks] Optional. May include `onStop` and\n * `onReady` callbacks. If a function is passed instead of an object, it is\n * interpreted as an `onReady` callback.\n */\nBlaze.TemplateInstance.prototype.subscribe = function (/* arguments */) {\n  var self = this;\n\n  var subHandles = self._subscriptionHandles;\n  var args = _.toArray(arguments);\n\n  // Duplicate logic from Meteor.subscribe\n  var callbacks = {};\n  if (args.length) {\n    var lastParam = _.last(args);\n    if (_.isFunction(lastParam)) {\n      callbacks.onReady = args.pop();\n    } else if (lastParam &&\n      // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n      // onStop with an error callback instead.\n      _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\n        _.isFunction)) {\n      callbacks = args.pop();\n    }\n  }\n\n  var subHandle;\n  var oldStopped = callbacks.onStop;\n  callbacks.onStop = function (error) {\n    // When the subscription is stopped, remove it from the set of tracked\n    // subscriptions to avoid this list growing without bound\n    delete subHandles[subHandle.subscriptionId];\n\n    // Removing a subscription can only change the result of subscriptionsReady\n    // if we are not ready (that subscription could be the one blocking us being\n    // ready).\n    if (! self._allSubsReady) {\n      self._allSubsReadyDep.changed();\n    }\n\n    if (oldStopped) {\n      oldStopped(error);\n    }\n  };\n  args.push(callbacks);\n\n  subHandle = self.view.subscribe.call(self.view, args);\n\n  if (! _.has(subHandles, subHandle.subscriptionId)) {\n    subHandles[subHandle.subscriptionId] = subHandle;\n\n    // Adding a new subscription will always cause us to transition from ready\n    // to not ready, but if we are already not ready then this can't make us\n    // ready.\n    if (self._allSubsReady) {\n      self._allSubsReadyDep.changed();\n    }\n  }\n\n  return subHandle;\n};\n\n/**\n * @summary A reactive function that returns true when all of the subscriptions\n * called with [this.subscribe](#TemplateInstance-subscribe) are ready.\n * @return {Boolean} True if all subscriptions on this template instance are\n * ready.\n */\nBlaze.TemplateInstance.prototype.subscriptionsReady = function () {\n  this._allSubsReadyDep.depend();\n\n  this._allSubsReady = _.all(this._subscriptionHandles, function (handle) {\n    return handle.ready();\n  });\n\n  return this._allSubsReady;\n};\n\n/**\n * @summary Specify template helpers available to this template.\n * @locus Client\n * @param {Object} helpers Dictionary of helper functions by name.\n */\nTemplate.prototype.helpers = function (dict) {\n  for (var k in dict)\n    this.__helpers.set(k, dict[k]);\n};\n\n// Kind of like Blaze.currentView but for the template instance.\n// This is a function, not a value -- so that not all helpers\n// are implicitly dependent on the current template instance's `data` property,\n// which would make them dependenct on the data context of the template\n// inclusion.\nTemplate._currentTemplateInstanceFunc = null;\n\nTemplate._withTemplateInstanceFunc = function (templateInstanceFunc, func) {\n  if (typeof func !== 'function')\n    throw new Error(\"Expected function, got: \" + func);\n  var oldTmplInstanceFunc = Template._currentTemplateInstanceFunc;\n  try {\n    Template._currentTemplateInstanceFunc = templateInstanceFunc;\n    return func();\n  } finally {\n    Template._currentTemplateInstanceFunc = oldTmplInstanceFunc;\n  }\n};\n\n/**\n * @summary Specify event handlers for this template.\n * @locus Client\n * @param {EventMap} eventMap Event handlers to associate with this template.\n */\nTemplate.prototype.events = function (eventMap) {\n  var template = this;\n  var eventMap2 = {};\n  for (var k in eventMap) {\n    eventMap2[k] = (function (k, v) {\n      return function (event/*, ...*/) {\n        var view = this; // passed by EventAugmenter\n        var data = Blaze.getData(event.currentTarget);\n        if (data == null)\n          data = {};\n        var args = Array.prototype.slice.call(arguments);\n        var tmplInstanceFunc = _.bind(view.templateInstance, view);\n        args.splice(1, 0, tmplInstanceFunc());\n\n        return Template._withTemplateInstanceFunc(tmplInstanceFunc, function () {\n          return v.apply(data, args);\n        });\n      };\n    })(k, eventMap[k]);\n  }\n\n  template.__eventMaps.push(eventMap2);\n};\n\n/**\n * @function\n * @name instance\n * @memberOf Template\n * @summary The [template instance](#template_inst) corresponding to the current template helper, event handler, callback, or autorun.  If there isn't one, `null`.\n * @locus Client\n * @returns {Blaze.TemplateInstance}\n */\nTemplate.instance = function () {\n  return Template._currentTemplateInstanceFunc\n    && Template._currentTemplateInstanceFunc();\n};\n\n// Note: Template.currentData() is documented to take zero arguments,\n// while Blaze.getData takes up to one.\n\n/**\n * @summary\n *\n * - Inside an `onCreated`, `onRendered`, or `onDestroyed` callback, returns\n * the data context of the template.\n * - Inside an event handler, returns the data context of the template on which\n * this event handler was defined.\n * - Inside a helper, returns the data context of the DOM node where the helper\n * was used.\n *\n * Establishes a reactive dependency on the result.\n * @locus Client\n * @function\n */\nTemplate.currentData = Blaze.getData;\n\n/**\n * @summary Accesses other data contexts that enclose the current data context.\n * @locus Client\n * @function\n * @param {Integer} [numLevels] The number of levels beyond the current data context to look. Defaults to 1.\n */\nTemplate.parentData = Blaze._parentData;\n\n/**\n * @summary Defines a [helper function](#template_helpers) which can be used from all templates.\n * @locus Client\n * @function\n * @param {String} name The name of the helper function you are defining.\n * @param {Function} function The helper function itself.\n */\nTemplate.registerHelper = Blaze.registerHelper;\n","UI = Blaze;\n\nBlaze.ReactiveVar = ReactiveVar;\nUI._templateInstance = Blaze.Template.instance;\n\nHandlebars = {};\nHandlebars.registerHelper = Blaze.registerHelper;\n\nHandlebars._escape = Blaze._escape;\n\n// Return these from {{...}} helpers to achieve the same as returning\n// strings from {{{...}}} helpers\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n"]}