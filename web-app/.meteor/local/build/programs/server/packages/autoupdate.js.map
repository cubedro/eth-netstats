{"version":3,"sources":["autoupdate/autoupdate_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,oE;AACA,sE;AACA,iD;AACA,E;AACA,2E;AACA,8E;AACA,8E;AACA,2D;AACA,gE;AACA,E;AACA,qE;AACA,mE;AACA,gE;AACA,mE;AACA,gE;AACA,uB;AACA,E;AACA,4D;AACA,qE;AACA,yE;AACA,qE;AACA,iE;AACA,0E;AACA,8E;AACA,yE;AACA,mE;AACA,qB;AACA,E;AACA,0E;AACA,+E;AACA,2E;AACA,2C;;AAEA,0C;;AAEA,gB;;AAEA,gD;AACA,yE;AACA,wB;;AAEA,oE;AACA,iE;AACA,kE;AACA,qB;;AAEA,2E;AACA,W;AACA,oC;AACA,+C;AACA,2C;AACA,wE;;AAEA,+C;;AAEA,uE;AACA,2D;AACA,yE;AACA,8C;AACA,kC;AACA,2C;AACA,G;;AAEA,6E;AACA,2B;AACA,2E;AACA,kC;AACA,uC;AACA,iD;AACA,G;AACA,yE;AACA,oD;AACA,+C;AACA,iC;;AAEA,2C;AACA,4D;AACA,uC;AACA,8C;;AAEA,uC;AACA,wD;AACA,uC;AACA,0C;;AAEA,uE;AACA,0C;AACA,kC;AACA,0C;AACA,G;;AAEA,0B;AACA,kD;AACA,+D;AACA,+D;AACA,8B;AACA,2C;AACA,G;;AAEA,mD;AACA,2B;AACA,qB;AACA,2C;AACA,O;AACA,U;AACA,8C;AACA,2C;AACA,Q;AACA,G;;AAEA,2D;AACA,2B;AACA,6B;AACA,mD;AACA,wB;AACA,O;AACA,U;AACA,sD;AACA,kD;AACA,Q;AACA,G;;AAEA,kD;AACA,iE;AACA,gE;AACA,kC;AACA,iE;AACA,6B;AACA,mC;AACA,yD;AACA,iD;AACA,S;AACA,Y;AACA,4D;AACA,yD;AACA,iD;AACA,U;AACA,K;AACA,K;AACA,E;;AAEA,e;AACA,qC;AACA,oB;AACA,oE;AACA,sE;AACA,8C;AACA,uD;;AAEA,8E;AACA,0D;AACA,gE;AACA,gB;;AAEA,iC;AACA,I;AACA,iB;AACA,E;;AAEA,4B;AACA,wB;AACA,G;;AAEA,uB;;AAEA,qE;AACA,6E;AACA,uE;AACA,8E;AACA,6E;;AAEA,iC;AACA,a;AACA,G;;AAEA,gC;AACA,e;AACA,G;;AAEA,0C;AACA,mC;AACA,yB;AACA,K;AACA,E;;AAEA,2E;AACA,4B;AACA,2D;AACA,oC;AACA,6B;AACA,G;AACA,I;;AAEA,iE;AACA,yD;AACA,2B;AACA,I","file":"/packages/autoupdate.js","sourcesContent":["// Publish the current client versions to the client.  When a client\n// sees the subscription change and that there is a new version of the\n// client available on the server, it can reload.\n//\n// By default there are two current client versions. The refreshable client\n// version is identified by a hash of the client resources seen by the browser\n// that are refreshable, such as CSS, while the non refreshable client version\n// is identified by a hash of the rest of the client assets\n// (the HTML, code, and static files in the `public` directory).\n//\n// If the environment variable `AUTOUPDATE_VERSION` is set it will be\n// used as the client id instead.  You can use this to control when\n// the client reloads.  For example, if you want to only force a\n// reload on major changes, you can use a custom AUTOUPDATE_VERSION\n// which you only change when something worth pushing to clients\n// immediately happens.\n//\n// The server publishes a `meteor_autoupdate_clientVersions`\n// collection. There are two documents in this collection, a document\n// with _id 'version' which represnets the non refreshable client assets,\n// and a document with _id 'version-refreshable' which represents the\n// refreshable client assets. Each document has a 'version' field\n// which is equivalent to the hash of the relevant assets. The refreshable\n// document also contains a list of the refreshable assets, so that the client\n// can swap in the new assets without forcing a page refresh. Clients can\n// observe changes on these documents to detect when there is a new\n// version available.\n//\n// In this implementation only two documents are present in the collection\n// the current refreshable client version and the current nonRefreshable client\n// version.  Developers can easily experiment with different versioning and\n// updating models by forking this package.\n\nvar Future = Npm.require(\"fibers/future\");\n\nAutoupdate = {};\n\n// The collection of acceptable client versions.\nClientVersions = new Mongo.Collection(\"meteor_autoupdate_clientVersions\",\n  { connection: null });\n\n// The client hash includes __meteor_runtime_config__, so wait until\n// all packages have loaded and have had a chance to populate the\n// runtime config before using the client hash as our default auto\n// update version id.\n\n// Note: Tests allow people to override Autoupdate.autoupdateVersion before\n// startup.\nAutoupdate.autoupdateVersion = null;\nAutoupdate.autoupdateVersionRefreshable = null;\nAutoupdate.autoupdateVersionCordova = null;\nAutoupdate.appId = __meteor_runtime_config__.appId = process.env.APP_ID;\n\nvar syncQueue = new Meteor._SynchronousQueue();\n\n// updateVersions can only be called after the server has fully loaded.\nvar updateVersions = function (shouldReloadClientProgram) {\n  // Step 1: load the current client program on the server and update the\n  // hash values in __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.reloadClientPrograms();\n  }\n\n  // If we just re-read the client program, or if we don't have an autoupdate\n  // version, calculate it.\n  if (shouldReloadClientProgram || Autoupdate.autoupdateVersion === null) {\n    Autoupdate.autoupdateVersion =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashNonRefreshable();\n  }\n  // If we just recalculated it OR if it was set by (eg) test-in-browser,\n  // ensure it ends up in __meteor_runtime_config__.\n  __meteor_runtime_config__.autoupdateVersion =\n    Autoupdate.autoupdateVersion;\n\n  Autoupdate.autoupdateVersionRefreshable =\n    __meteor_runtime_config__.autoupdateVersionRefreshable =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashRefreshable();\n\n  Autoupdate.autoupdateVersionCordova =\n    __meteor_runtime_config__.autoupdateVersionCordova =\n      process.env.AUTOUPDATE_VERSION ||\n      WebApp.calculateClientHashCordova();\n\n  // Step 2: form the new client boilerplate which contains the updated\n  // assets and __meteor_runtime_config__.\n  if (shouldReloadClientProgram) {\n    WebAppInternals.generateBoilerplate();\n  }\n\n  // XXX COMPAT WITH 0.8.3\n  if (! ClientVersions.findOne({current: true})) {\n    // To ensure apps with version of Meteor prior to 0.9.0 (in\n    // which the structure of documents in `ClientVersions` was\n    // different) also reload.\n    ClientVersions.insert({current: true});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version\"})) {\n    ClientVersions.insert({\n      _id: \"version\",\n      version: Autoupdate.autoupdateVersion\n    });\n  } else {\n    ClientVersions.update(\"version\", { $set: {\n      version: Autoupdate.autoupdateVersion\n    }});\n  }\n\n  if (! ClientVersions.findOne({_id: \"version-cordova\"})) {\n    ClientVersions.insert({\n      _id: \"version-cordova\",\n      version: Autoupdate.autoupdateVersionCordova,\n      refreshable: false\n    });\n  } else {\n    ClientVersions.update(\"version-cordova\", { $set: {\n      version: Autoupdate.autoupdateVersionCordova\n    }});\n  }\n\n  // Use `onListening` here because we need to use\n  // `WebAppInternals.refreshableAssets`, which is only set after\n  // `WebApp.generateBoilerplate` is called by `main` in webapp.\n  WebApp.onListening(function () {\n    if (! ClientVersions.findOne({_id: \"version-refreshable\"})) {\n      ClientVersions.insert({\n        _id: \"version-refreshable\",\n        version: Autoupdate.autoupdateVersionRefreshable,\n        assets: WebAppInternals.refreshableAssets\n      });\n    } else {\n      ClientVersions.update(\"version-refreshable\", { $set: {\n        version: Autoupdate.autoupdateVersionRefreshable,\n        assets: WebAppInternals.refreshableAssets\n      }});\n    }\n  });\n};\n\nMeteor.publish(\n  \"meteor_autoupdate_clientVersions\",\n  function (appId) {\n    // `null` happens when a client doesn't have an appId and passes\n    // `undefined` to `Meteor.subscribe`. `undefined` is translated to\n    // `null` as JSON doesn't have `undefined.\n    check(appId, Match.OneOf(String, undefined, null));\n\n    // Don't notify clients using wrong appId such as mobile apps built with a\n    // different server but pointing at the same local url\n    if (Autoupdate.appId && appId && Autoupdate.appId !== appId)\n      return [];\n\n    return ClientVersions.find();\n  },\n  {is_auto: true}\n);\n\nMeteor.startup(function () {\n  updateVersions(false);\n});\n\nvar fut = new Future();\n\n// We only want 'refresh' to trigger 'updateVersions' AFTER onListen,\n// so we add a queued task that waits for onListen before 'refresh' can queue\n// tasks. Note that the `onListening` callbacks do not fire until after\n// Meteor.startup, so there is no concern that the 'updateVersions' calls from\n// 'refresh' will overlap with the `updateVersions` call from Meteor.startup.\n\nsyncQueue.queueTask(function () {\n  fut.wait();\n});\n\nWebApp.onListening(function () {\n  fut.return();\n});\n\nvar enqueueVersionsRefresh = function () {\n  syncQueue.queueTask(function () {\n    updateVersions(true);\n  });\n};\n\n// Listen for the special {refresh: 'client'} message, which signals that a\n// client asset has changed.\nprocess.on('message', Meteor.bindEnvironment(function (m) {\n  if (m && m.refresh === 'client') {\n    enqueueVersionsRefresh();\n  }\n}));\n\n// Another way to tell the process to refresh: send SIGHUP signal\nprocess.on('SIGHUP', Meteor.bindEnvironment(function () {\n  enqueueVersionsRefresh();\n}));\n\n"]}